  Phit
  Bruce Ravel, ravel@u.washington.edu
  version 0.13, 14 December, 1995

  Fit an arbitrary lineshape to real data.
  ______________________________________________________________________

  Table of Contents:

  1.      Introduction

  2.      Input and Output Files

  2.1.    Input Files

  2.2.    Running Phit, Output Messages, Warnings, and Errors

  2.3.    Output Files

  3.      Keywords

  3.1.    A Brief List of the Keywords

  3.2.    Full Explanation of Keywords

  4.      Available functions

  4.1.    List of Functions

  4.2.    Rules for Using Functions

  4.3.    The Peak Function.

  5.      Writing Sensible Input Files

  5.1.    Specifying Keywords

  5.2.    Guess and Set Values

  5.3.    Writing Math Expressions

  5.4.    Choosing Variable Labels

  5.5.    Functions Other Than Those Found in Phit

  5.6.    Using Phit without Fitting

  6.      Goodness of Fit and Uncertainty in Variables

  7.      Acknowledgments, References, and Program Notes

  7.1.    Acknowledgments

  7.2.    Bibliography

  7.3.    Copyright Issues

  7.4.    Obtaining New Copies of FEFF or of the UWXAFS Analysis
  Programs

  7.5.    To Do

  7.6.    Source Code Parameters

  7.7.    Code Portability and Code Compilation

  7.8.    Adding More Data Formats to Phit

  7.9.    About this document.

  8.      Appendix:  Some Worked Examples

  8.1.    Fitting a Line + a Gaussian + Noise

  8.2.    Fitting An Einstein Temperature to XAFS Debye-Waller Factors

  8.3.    Fitting the Near Edge Structure of Barium Titanate
  ______________________________________________________________________

  1.  Introduction

  Phit will fit a sum of line shapes to a real data set.  The line
  shapes and variable parameters used in the fit are specified by the
  user.  The parameters are varied using a Levenberg-Marquardt non-
  linear least-squares minimization to best fit the input data.  All
  information needed by Phit, including the data file name, the line
  shapes, and the parameter list, are supplied in a plain text input
  file called phit.inp.

  Phit performs extensive error analysis including measuring the
  goodness of fit and estimating error bars on the variable parameters.
  This is intended to help the user interpret the fit and extract
  physically significant results from the data.

  Many portions of this document are copied or modified from the
  document for Feffit, the XAFS fitting program written by Matt Newville
  for the UWXAFS package.  Phit borrows several concepts and algorithms
  from that program.  Chapter 5 in the Feffit document is about goodness
  of fit and error analysis and serves well as a description of those
  concepts for this program.

  Phit, as well as this document, is intended to meet the needs of a
  sophisticated user as well as a first time user.  Much of this
  document is a reference manual covering all of the features and
  functionality of the program.  Also included are several worked
  examples.  The first time user should read these carefully and work
  through them at the computer.  Sample data files and input files are
  distributed with the program.

  2.  Input and Output Files

  Please read the UWXAFS Data File Document for information about the
  data file formats accepted by Phit and the other UWXAFS programs.

  2.1.  Input Files

  Phit uses the input file phit.inp to control the running of the
  program.  If this file cannot be found in either lower case or upper
  case characters, Phit will stop and complain.  The form and contents
  of phit.inp will be discussed further in Chapter 3.  Phit usually
  needs an input data file.  The file contains real valued data.
  Complex valued data is not handled by Phit.  There are no constraints
  on the input data grid, Phit will use whatever abscissa values it
  finds.  The data file name can be up to 72 characters long and can
  contain a directory path.  The file name and path must be allowed by
  your operating system.

  Since Phit is written in Fortran, the file reading conventions of
  Fortran are observed.  The input file and the data file are read using
  the end qualifier for the read statement.  This means that the reading
  of the file will end when the end-of-file marker is found.  If the
  end-of-file marker does not follow a carriage return, then the line
  containing the end-of-file marker will not be read as input
  instructions in the input file or as data in the data file.  If you
  are always careful to end an input file or a data file with a carriage
  return, then the last line of instructions or data will always be read
  properly.

  2.2.  Running Phit, Output Messages, Warnings, and Errors

  Phit is a compiled program, so should be executable from the command
  interface on your computer.  Phit writes several messages as it runs.
  Mostly these messages communicate which task the program is performing
  at the time of writing the message.  If Phit encounters a problem, the
  run-time messages will describe it.  If the problem is serious, Phit
  will complain and stop running.  The error messages that Phit writes
  should supply enough information to correct the problems encountered.
  If this is not true, contact the author.

  2.3.  Output Files

  As soon as the fitting and error analysis are finished, a log file,
  usually called phit.log, will be written.  This file will contain all
  of the input information, the fitting results, and the results of the
  error analysis.  Most of this information is not contained in any
  other output file, so this is file is quite important.  After the log
  file is written, the best fit function will be written to an output
  data file.  If requested, files containing each individual line shape
  will also be written.

  This is the naming convention for the output files:

  1. If an output file name is specified in the input file, that name
     will be used verbatim for the result of the fit.

  2. If no output file name is specified, the extension will be removed
     from the input file name and replaced with fit if the output file
     format is ASCII and with xmu if the output format is UWXAFS.  The
     extension is defined as all characters after the final dot (.) in
     the file name.  This definition of extension is unambiguous on all
     operating systems.

  3. If no output file name is specified and no fit is performed, the
     calculation of the line shape will be written to a file named by
     replacing the extension of the input file name with out if the
     output file format is ASCII, and with xmu if the output format is
     uwxafs.

  4. If no input data is supplied and no output file name is specified,
     the results of the calculation of the line shape will be written to
     phit.out.

  5. If output files containing each individual function are requested,
     these will be written to files named by replacing the extension of
     the file containing the sum of functions with the function number
     as specified in the input file.

  3.  Keywords

  Take a peek at the Appendix.  Included there are a few examples of
  input files for Phit.  This chapter explains the meanings of all the
  keywords recognized by Phit.

  Phit.inp uses keywords to describe the input parameters. With only a
  few exceptions, the keywords are allowed to occur in any order in the
  file, and usually have transparent meanings.  This structure allows
  the input file to be easily read and modified.  All keywords use the
  syntax:

               keyword delimiter value(s) delimiter ...

  The delimiter can be:

  1. one or more white spaces (blanks and/or TABs)

  2. one equal sign and any number of white spaces

  3. one comma and any number of white spaces

  Most keywords take only one value. Many keywords can be put on one
  line (though some keywords require their own line).  Internal comments
  can be written anywhere in phit.inp, which help remind you what the
  keywords mean, or how you chose the input values. Keywords can be in
  upper, lower, or mixed case. Phit is not sensitive to the case of
  keywords or their values.

  3.1.  A Brief List of the Keywords

  1. !, %, #  --  characters denoting comments

  2. title --  user supplied title line

  3. comment --  synonymous with title

  4. include -- name of an include file

  5. data --  name of input data file

  6. read --  synonymous with data

  7. infile --  synonymous with data

  8. nkey --  numeric key of input UWXAFS data record

  9. skey --  symbolic key of input UWXAFS data record

  10.
     outfile --  name of output file

  11.
     logfile --  name of log file
  12.
     format --  i/o file format

  13.
     formin --  input file format

  14.
     formout --  output file format

  15.
     write --  output data range

  16.
     xaxis --  abscissa label in math expressions

  17.
     sigma --  logical flag for input measurement uncertainty

  18.
     sigdat --  constant input measurement uncertainty

  19.
     cormin --  minimum correlation reported in log file

  20.
     x1 - x10 --  fitting range values

  21.
     xmin --  minimum fitting range

  22.
     xmax --  maximum fitting range

  23.
     npoints --  number of points in nofit output

  24.
     end --  flag marking end of input file

  25.
     all --  logical flag for writing out individual functions

  26.
     residual --  logical flag for writing out array of residuals

  27.
     nosum --  logical flag for not writing sum of functions

  28.
     noout --  logical flag for writing no output files

  29.
     norun --  logical flag for stopping after reading input file and
     data file

  30.
     dryrun --  synonymous with norun

  31.
     nofit --  logical flag for only summing functions

  32.
     noerr --  logical flag for skipping error analysis

  33.
     guess --  parameter to vary in fit
  34.
     set --  parameter set by a math expression

  35.
     function --  math expression, part of sum in fit

  36.
     id --  description line for corresponding function

  3.2.  Full Explanation of Keywords

      !, %, and #
        These characters denote comments in the input file.  Anything on
        a line following any one of these characters will be ignored
        unless they follow the keywords title, comment, or id in which
        case they will be part of the title or id line.

      Title or Comment
        This is a title line that will be written to the log file and to
        each output data file.  It can be used to describe and document
        a run of the program.  Up to 9 title lines of 72 characters each
        are allowed.

      Include
        This is the name of a file that contains additional keywords to
        be parsed when the input file is read.  The include file name
        can be up to 72 characters long and may contain a directory
        path.  The include file is read according to the same syntax as
        phit.inp.  All keywords read in the include file are handled
        equivalently to those in phit.inp.  The line containing the
        keyword include is entirely parsed before the include file is
        opened and read.  When the include file is finished, parsing of
        the input file will continue.  Nested include files are allowed
        although there is a limit to how deeply they may be nested.
        Include files are never necessary but are allowed as an
        organizational convenience for complicated input files.

      Data, Read, or Infile
        This is the name of the input data file.  It may be up to 72
        characters long and may contain a directory path.  The filename
        should not contain spaces, tabs, commas (,), or equal signs (=).
        These characters will confuse the parsing algorithm.  The
        abscissa grid provided in the input file is used for writing out
        the output data.  See the full description of the x1 - x10
        keywords for a discussion of how a limited fitting range can be
        chosen. Not providing an input file name is equivalent to
        setting the nofit flag or to providing no guess values.  In this
        case, Phit will evaluate and sum the functions using the guess
        and set values as stated in the input file.  See the full
        description of the npoints keyword for a discussion of how the
        output abscissa grid is chosen if no input data file is
        provided.

      Nkey and Skey
        These are the numeric and symbolic keys that identify a record
        in a UWXAFS data file.  See the data format document in the
        UWXAFS package for more details on this file format.  At least
        one of these two must be specified if the UWXAFS file format is
        used.

      Outfile
        This is the name for the file containing the sum of functions.
        The file names for the individual functions will be the same
        with the extension replaced with the function number from the
        input file.  If no output file name is specified, the input file
        name will be used with the extension changed to fit, out, or the
        function number, as appropriate.  The file extension is defined
        as all characters after the final dot (.) in the file name.
        This definition meets the definition of an extension in DOS and
        VMS, and is well defined in a Unix environment.

      Logfile
        This is the name of the log file.  The input parameters, set
        math expressions, functions and ids, results of the fit, and
        results of the error analysis will be written to this file.
        Much of this information will not be written anywhere else, so
        this is an important file!  The default name for this file is
        phit.log.

      Format, Formin, and Formout
        These specify the formats for the input and output data files.
        By default, files are read in the ASCII format.  The other
        option is the UWXAFS format.  The format keyword specifies both
        input and output format.  Note that the input and output formats
        do not need to be the same.

      Write
        This determines how the output data will be written to the
        output data files.  If this keyword is set to full, the sum of
        functions and individual functions will be evaluated at each
        input abscissa value in the input file.  If it is set to fit,
        the functions will only be evaluated at abscissa values within
        the fitting ranges.  This is set to full by default.

      Xaxis
        This is a character string that will be used to denote the
        abscissa in all math expressions.  By default this is x, but
        something else might be more appropriate for a specific problem.
        For instance if the input data is an XAFS spectrum in energy,
        this might be set to e.  If the input data is in temperature, it
        might be T.

      Sigma
        If a third column containing measurement uncertainties at each
        abscissa value is provided in the input file, Phit will use
        those in calculating chi-square and in the error analysis if
        this keyword is found in the input file.  This keyword does not
        take any value.  Simply placing it somewhere in the input file
        will toggle this logical flag.  If no information about
        measurement uncertainties is provided in the input file, a
        single number which is the standard deviation of the residuals
        of the fit will be used.

      Sigdat
        To evaluate chi-square using a single, user-chosen number,
        specify it with this keyword.  It will be used to evaluate chi-
        square and to perform the error analysis.  If no information
        about measurement uncertainties is provided in the input file, a
        single number which is the standard deviation of the residuals
        of the fit will be used.  This value of sigma will be used to
        normalize chi-square and the error bars.

      Cormin
        Part of the error analysis is the computation of correlations
        between variables.  By default, only those variables with more
        than 15% correlation will be written to the log file.  This
        limit can be changed with this keyword.  It takes a value
        between 0 and 1.

      X1 through X10
        These values can be used to limit the range of the fit to some
        subset of the input data range.  They take values within the
        range of the abscissas of the input data and are specified in
        pairs.  Only the input data between x1 and x2 and between x3 and
        x4 and so on will be included in the fit.  The data between x2
        and x3 and so on will be excluded from the fit.  Chi-square and
        the error analysis will be computed using only the data
        contained within these abscissa ranges.  By default x1 is the
        first data point, x2 is the last data point, and the other eight
        are unused.  The values of these keywords will be sorted on
        input and if an odd number of values are found, the last data
        point will be inserted into the list.  When functions are
        evaluated with the fitting results and written to the output
        data files, they can either be evaluated in the fitting range as
        specified by these keywords or in the range of the input data.
        This is determined by the keyword write.

      Xmin and Xmax
        These are synonymous with X1 and X10.  When only the ends of the
        input data range are being excluded, these keywords are perhaps
        more mnemonic.

      Npoints
        This keyword is only used in the situation where functions are
        evaluated without performing any fit.  If no input data is
        specified, then Phit needs some way to determine an abscissa
        grid over which to evaluate the functions.  In this situation,
        Phit will make an even grid containing npoints points between
        xmin and xmax and evaluate the function on that grid.  If an
        input data file is specified and no fit is called for, the Phit
        will use the abscissa grid between xmin and xmax from that data
        file and ignore the value of npoints.  By default, npoints is
        100.

      End
        When this keyword is encountered in the input file, Phit will
        stop reading the input file and begin the fit.  Everything after
        this keyword in the input file will be ignored.  This keyword
        takes no value.

      All
        This is a logical flag telling Phit to write out each individual
        function.  This keyword takes no value, simply writing it to the
        input file will toggle this logical flag.

      Residuals
        This is a logical flag telling Phit to write out an array
        containing the residual at each data point written to the output
        file.  If the value of the keyword write is fit and the output
        files only contain the function evaluations at the data points
        used in the fit, then the residual file will contain the
        residual used in evaluating chi-square.  If write is set to
        full, then the residual file will contain the difference between
        the function evaluations and the data at every data point in the
        input data file and is not the residual array used to evaluate
        chi-square.  This keyword takes no value, simply writing it to
        the input file will toggle this logical flag.

      Nosum
        This is a logical flag telling Phit not to write out the sum of
        functions.  This keyword takes no value, simply writing it to
        the input file will toggle this logical flag.

      Noerr
        This is a logical flag telling Phit not to perform any error
        analysis.  This keyword takes no value, simply writing it to the
        input file will toggle this logical flag.

      Noout
        This is a logical flag telling Phit to write out neither the sum
        of functions nor the individual functions.  This keyword  takes
        no value, simply writing it to the input file will toggle this
        logical flag.

      Norun or Dryrun
        This is a logical flag telling Phit to stop after reading the
        input data file.  The input file and the data file will be read
        and all math expressions will be interpreted before stopping.
        This option is useful for ``spell checking'' your input file.
        This keyword takes no value, simply writing it to the input file
        will toggle this logical flag.

      Nofit
        This is a logical flag telling Phit to not perform a fit.
        Instead the functions and set values will be evaluated at the
        initial guess values specified in the input file and will be
        written to output files.  This keyword takes no value, simply
        writing it to the input file will toggle this logical flag.

      Guess
        This keyword takes two values and must be placed on its own
        line.  The first value is the label that will be used in your
        math expressions and the second value is the initial guess of
        this parameter.  The label is a character string of up to 20
        characters and the initial guess is a number.  Up to 50 guess
        values can be specified.  It is prudent to choose an initial
        guess that is somewhat close to what you expect for the best fit
        value.  For some line shapes, a poor initial guess can confound
        the minimization algorithm resulting either in an inability to
        minimize chi square or in the location of a false minimum of the
        parameter set.  See chapter 5 for more discussion of appropriate
        initial guesses.  Setting no guess values is equivalent to
        setting the nofit flag.

      Set
        This keyword takes two values and must be placed on its own
        line.  The first value is a label that will be used to identify
        this value in other math expressions.  The second value is a
        math expression which will be evaluated and whose value will be
        assigned to its label for use in evaluating other math
        expressions.  The label is a character string of up to 20
        characters.  The math expression is a character string of up to
        74 characters.  Up to 300 set values can be specified.  The set
        value must be contained on one line.  Phit will not read a math
        expression that stretches over more than one line.  If a math
        expression is very long, it would be prudent to break it up into
        smaller ones.  See Chapter 5 for more discussion of writing good
        math expressions.

      Function
        This keyword takes two values and must be placed on its own
        line.  The first value is an integer which is the index
        identifying the function.  The second is a math expression which
        will be evaluated as part of the sum of functions to fit to the
        data.  This is a character string of up to 74 characters.  Up to
        20 functions can be specified.  The function must be contained
        on one line -- Phit will not read a math expression that
        stretches over more than one line.  If the math expression is
        very long, it would be prudent to write it in terms of several
        set values.  See chapter 5 for more discussion of writing good
        math expressions.

      Id
        This keyword takes two values and must be placed on its own
        line.  The first values is an integer which is the index of the
        function associated with this id line.  The second value is a
        character string of up to 74 characters.  This is a comment line
        specifically associated with a particular function.  It will be
        written to individual function data file, if that output is
        requested, and it will be written along with its function in the
        log file.  Id lines with an integer index shared by no functions
        will be ignored.

  4.  Available functions

  Phit recognizes many arithmetic operations, trigonometric functions,
  and other special line shapes and functions.  See the next chapter for
  hints on how to use these forms in constructing math expressions.

  4.1.  List of Functions

  o  Unary arithmetic operators + and -

  o  Binary arithmetic operators +, -, *, /, **, and  ^.  ** and ^ are
     equivalent and indicate exponentiation.

  o  Functions of a single argument:

     1. abs(x) -- absolute value of x

     2. neg(x) -- negation (parity change) of x

     3. sqrt(x) -- square root of x

     4. exp(x) -- natural exponent of x, e^x where e =
        2.71828182845904523536...

     5. ln(x) -- natural log (log base e) of x

     6. log10(x) -- log base 10 of x

     7. sin(x) -- sine of x, argument in radians

     8. cos(x) -- cosine of x, argument in radians

     9. tan(x) -- tangent of x, argument in radians

     10.
        cot(x) -- cotangent of x, argument in radians

     11.
        sec(x) -- secant of x, argument in radians

     12.
        csc(x) -- cosecant of x, argument in radians

     13.
        asin(x) -- arcsine (inverse sine) of x in radians

     14.
        acos(x) -- arccosine (inverse cosine) of x in radians

     15.
        atan(x) -- arctangent (inverse tangent) of x in radians

     16.
        sinh(x) -- hyperbolic sine of x

     17.
        cosh(x) -- hyperbolic cosine of x

     18.
        tanh(x) -- hyperbolic tangent of x

     19.
        coth(x) -- hyperbolic cotangent of x

     20.
        sech(x) -- hyperbolic secant of x

     21.
        csch(x) -- hyperbolic cosecant of x

     22.
        int(x) -- integer part of a floating point number

     23.
        nint(x) -- nearest integer to a floating point number

  o  Special functions of multiple arguments

     1. step(x, x0) -- returns 0 if x<x0, 1 if x>x0

     2. gauss(x, x0, w) -- Gaussian function = exp( -((x-x0)/w)^2 ) /
        sqrt(pi), x0 is the peak position of the Gaussian, w is the
        width.  This Gaussian is normalized to unit area.

     3. lor(x, x0, w) -- Lorentzian function = 0.5 / ( ((x-x0)/w)^2 + 1
        ), x0 is the peak position of the Lorentzian, w is the width.
        This Lorentzian is normalized to unit area.

     4. eins(t, theta, rmass) -- Einstein formula for mean square
        displacement of a bond, t is the temperature, theta is the
        Einstein temperature, and rmass is the reduced mass of the atom
        pair in atomic units.

     5. min(x1,x2) -- returns the smaller of x1 and x2

     6. max(x1,x2) -- returns the larger of x1 and x2

     7. peak(lambda,h,k,l,a,b,c,alpha,beta,gamma) -- returns the
        position of a diffraction peak in degrees.

  o  Special constants

     1. pi -- 3.14159265358979323844...

  4.2.  Rules for Using Functions

  Arguments to functions must be enclosed by parentheses.  For instance
  cos(pi) evaluates to 1.

  Arguments to trigonometric functions must be in radians.  Use set
  values to convert between degrees and radian, if desired.  Here is an
  example of varying an angle in degrees and calculating the function in
  radians:

               guess           alphad  0
               set             alpha   alphad * pi / 180
               function        1       tan(alpha)

  Some of these function have singular values. Be very careful when
  using singular functions in a fit.  There is no problem using these
  functions in your fitting model so long as the singular point is not
  included in your fit.  The residual at this point will be so much
  larger than any other in the fit, that the minimization will be ill-
  posed.  If the singular point is excluded either by judicious choice
  of input grid or by excluding data from the fit by using the x1 - x10
  keywords, then the fit should be well behaved.

  Functions with singular or undefined values for certain values of the
  argument are error checked before evaluating to avoid run-time errors.
  For example, ln(-1) will return 0, atan(0) will return 10^40, and so
  on.  The program will therefore not crash if a function is poorly used
  in a fitting model.  The quality of the fit, however, should be quite
  poor.

  Int and nint might be troublesome functions in the fit, since changes
  in the argument can produce absolutely no change in the evaluation of
  the function.  They are included for completeness -- use them with
  caution.  Note that int(3.7) = 3 and nint(3.7) = 4.  Also, int(2)
  might return 1 if your computer represents the floating point value of
  2 as, for instance, 1.99999837, which is a valid representation.

  The commas in the argument lists to the special functions of multiple
  arguments are necessary.  In my experience, a reasonably good first
  guess for the peak positions of the Gaussian and Lorentzian functions
  is necessary for a well-posed fitting problem.

  The temperatures in the Einstein function are in Kelvin and the
  reduced mass is in atomic units.  Here is a good way to specify the
  reduced mass:

               set     r_cu    63.546
               set     r_ba    137.33
               set     rmass   1 / ( 1/r_cu + 1/r_ba )

  At present, pi is the only recognized special constant.

  4.3.  The Peak Function.

  This is a function of ten arguments (!) that returns the position of a
  diffraction peak in two-theta and in degrees.  The arguments are the
  x-ray wavelength, the Miller indices, the cell axis lengths, and the
  cell angles.  The wavelength and axis lengths must be in consistent
  units.  That is, all four must be in angstroms or in nanometers or
  whatever.  The function will behave identically for different units,
  so long as they are consistent.  The cell angles are in degrees.
  Fractions of degrees should be specified as decimals rather than
  minutes and seconds of arc.  All ten arguments must be specified.  The
  value for the angle that is returned is the angle of the two-theta
  circle.

  This function only is used for peak position, which is dependent only
  on the geometry of the unit cell of a crystal.  It is derived from
  Bragg's law and uses the formulas for interplanar spacing and cell
  volume in a triclinic cell.  This should be well described in any
  introductory crystallography text book.  Phit presently has no
  specific capability for computing crystallographic amplitude and
  width.  A Gaussian or a Lorentzian (or some linear combination of the
  two) centered at the position found by the peak function is a
  reasonable approximation of the shape of a diffraction peak.

  5.  Writing Sensible Input Files

  5.1.  Specifying Keywords

  Phit reads the input file by reading in a single line at a time and
  parsing the words on that line.  Words in the line are separated by
  white space, where the white space can be zero or one comma or equals
  sign along with any number of spaces and tabs.  Each word is compared
  to a list of recognized keywords.  If it is found, the appropriate
  number of words following the recognized keyword are interpreted as
  the values associated with that keyword.  For instance, if the
  following words are found in a line:

               xaxis  =  e

  the word xaxis will be recognized as a keyword and the word e will be
  interpreted as the character string labeling the xaxis.  If this is
  found:

               sigdat     =3.0956

  then sigdat will be recognized as a keyword and the character string
  3.0956 will be internally read as a floating point number.  In this
  case:

               function        1       m*x + b

  function will be recognized, 1 will be read as an integer, and the
  remainder of the line will be recognized as the math expression asso-
  ciated with function #1.

  This parsing scheme allows the input file to read more like common
  English and is intended to facilitate use of a rather complicated
  program.  The parsing scheme is insensitive to case, so GUESS is
  equivalent to guess, Guess, and gUEsS.  Blank lines and lines
  beginning with the comment characters !, %, or # will be ignored, as
  will id lines that correspond to no function and title lines in excess
  of 9.  Recall that the white space between words can be any number of
  tabs or blanks and no more than one comma or equals sign.

  There is little established order in which the keywords must be found
  in the input file.  The only structure imposed on the input file is
  that everything on a line after the keyword title will be included in
  the title and that the keywords guess, set, function, and id must be
  on their own lines.

  5.2.  Guess and Set Values

  The guess values are the parameters that will actually be varied to
  produce the best fit.  The labels for the guess values are used to
  identify these parameters in the set value and function math
  expressions.  The initial guess must be a number.  It cannot be a math
  expression.

  All guess values must be used in math expression.  Any unused guess
  value will cause an error message to be written to the screen and the
  program to stop.  The minimization algorithm is ill-posed if a
  variable has no effect on the function being minimized.  There is
  still a pitfall of unused guess values.  If the guess value is used to
  evaluate a set value and the set value is not used in any function,
  then the minimization will be ill-posed.

  The set values are stated in the input file as math expressions, where
  the math expression can be simply a number or some valid combination
  of numbers, special functions, other set and guess values, and
  operators.  If a set value is unused in other math expressions, a
  warning will be written to the screen, but the program will continue.
  Set values can depend on other set values, but they cannot be self-
  referencing.  That is, a set value may not depend on itself, as in:

          a = a+1

  If a self-referencing set value is found, an error message will be
  written to the screen and the program will stop.

  5.3.  Writing Math Expressions

  The algorithm for encoding the math expressions found in the input
  file follows the Fortran standard for operator precedence.  Quantities
  in parentheses and special functions will be evaluated first, followed
  in order by exponentiation, multiplication/division, and
  addition/subtraction.

  Blanks and tabs are removed from math expressions before encoding.
  Using blanks to make math expressions more easily understood to the
  human reader of the input file in encouraged.

  The arguments to special functions must be enclosed in parentheses and
  must be separated by commas.  Functions of a single argument need no
  commas.  Functions of more than one argument make no assumptions about
  the value of the arguments, so all arguments must be specified.

  There is a known bug in the encoding algorithm.  If a function of more
  than one argument is passed as the argument of a function of more than
  one argument, there will be an error counting the commas.  The
  following will trip this bug:

               set     a       gauss( e,  min(1, center), width)

  This would constrain the center point of the Gaussian to be no larger
  than 1.  If this is what you want, you should do this instead:

               set     b       min(1,center)
               set     a       gauss( e, b, width)

  Because all math expressions must be contained on a single line, writ-
  ing math expressions in terms of set values is often necessary.

  The great value of this scheme of guess values and math expressions is
  that arbitrarily robust and complex fitting models can be introduced.
  For example, more than one function can depend on one variable
  parameter.  Thus the set of variables can be small and robust.  The
  set of functions actually summed and used in the fit is easily created
  and changed by the user, allowing many different fitting models to be
  tested.

  If any mistakes are found in any math expression, a warning message
  containing the nature of the problem will be written to the screen and
  the program will stop.

  5.4.  Choosing Variable Labels

  The labels associated with the set and guess values and with the xaxis
  are completely arbitrary and subject to the preferences of the user.
  Choosing variable names that are mnemonic is a good idea.  If the data
  that you are fitting is measured in energy, then e might be chosen as
  the xaxis label for use in the math expressions.  The variable
  associated with the width of a Lorentzian function might be width.  It
  might also be called chthon or anything else that has meaning to you.

  The labels for the set and guess values and the xaxis must be less
  than 20 characters.  They must be composed of keyboard characters that
  are unambiguous in the context of math expressions.  This means that
  +, -, *, /, ^, (, and ) cannot be part of a label.  For example, the
  expression h-bar will be interpreted as the value of bar subtracted
  from the value of h.  The names of functions understood by Phit can,
  in fact, be variable names.  Phit recognizes function names as
  functions when followed immediately by an open parenthesis (().  This
  math expression:

               sinh * sinh(3)

  will thus be interpreted as the variable sinh multiplied by the hyper-
  bolic sine of 3.

  5.5.  Functions Other Than Those Found in Phit

  If you need a function that is not recognized by the math expression
  encoder, there is a solution that does not involve modifying the
  Fortran source code.  If your function is representable in a
  reasonable number of terms, then the new function can be expressed as
  a sum of set values in the input file.  Here, for instance, is the
  math expression for a fifth order Legendre polynomial as a function of
  the xaxis label x:

               set     leg5    (63*x**5 + 70*x**3 + 15*x) / 8

  You could define some number of Legendre polynomials in this fashion
  and fit data as a weighted expansion in Legendre polynomials.  If your
  function is described by a series expansion that is convergent in a
  small number of terms, this technique of using set values will work
  well.

  A function commonly used to analyze XANES is the pseudo-Voight
  function.  This is a linear combination of a Lorentzian and a
  Gaussian.  This could be constructed as follows:

          guess   x0        0             ! center of function
          guess   g_width   1             ! gaussian width
          guess   l_width   1             ! lorentzian width
          guess   nu        0.5           ! relative weight lineshapes
          set     g         gauss(x, x0, g_width)
          set     l         lor(x, x0, l_width)
          set     voight    nu * g + (1-nu) * l

  In this example, a pseudo-Voight is constructed and four variables
  describing the function are allowed to float.

  5.6.  Using Phit without Fitting

  Occasionally Phit is run without performing a fit.  One might use Phit
  to construct some complicated line shape or to evaluate a fitting
  function at its initial guess values.  There are three ways make Phit
  run to completion without performing a fit:

  1. Use the nofit keyword.

  2. Specify no guess values.

  3. Specify no input data set.

  If the nofit keyword is specified then the set and function math
  expressions will be evaluated using the initial values of the guess
  parameters.  The sum of functions and, if requested, the individual
  functions will be written to disk.  The functions will be evaluated on
  the x-axis grid of the input data file.

  If no guess parameters are specifies, then the functions will be
  evaluated using the set values on the data grid of the input data
  file.

  If no input data is specified, the sets and functions will be
  evaluated using the initial values for any guess functions.  The
  functions will be evaluated on an evenly spaced data grid determined
  by the values of the keywords xmin, xmax, and npoints.

  6.  Goodness of Fit and Uncertainty in Variables

  This topic is discussed in detail in Chapter 5 of Matt Newville's
  Feffit document.  For good literature references see Data Reduction
  and Error Analysis for the Physical Sciences by Philip R. Bevington
  and Numerical Recipes by Press, et al.  Rather than rehashing what is
  said in those places, I will only point out differences between the
  error analysis in Feffit and Phit.

  The most important difference is that the summations for chi-square
  and the R-factor are over both the real and imaginary parts in Feffit.
  Since Phit deals strictly with real valued data, these summations are
  only over real values.  Thus, the R-factor is defined as the sum of
  the squares of the residuals divided by the sum of squares of the
  data.  (See Eq. 5.7 in the Feffit document.)

  In the Feffit document, the measurement uncertainty is referred to as
  epsilon.  Here I have been calling it sigma.  Ok.  In Feffit the
  uncertainty is estimated from a part of the Fourier transformed signal
  that is spectrally distinct from the analyzed part of the data.  Phit
  cannot use any such tricks.  If the measurement uncertainty at each
  point is somehow already known, then it can be input into the program
  as part of the data file.  This requires using the keyword sigma.
  Alternatively, a single value for sigma can be entered in the input
  file with the keyword sigdat.  If no information about sigma is
  provided by the user, then Phit will use the standard deviation of the
  residuals as the value of sigma.  The residuals are the differences at
  each point between the data and the sum of functions evaluated at the
  best fit values of the parameters.

  Using the standard deviation of the residuals as the value of sigma
  assures that the value of chi-square for any fit will be nearly 1.
  This is true even in the case of a fit that is obviously poor by
  visual inspection.  If this option for evaluating sigma is used, chi-
  square is not a valid criteria for ascertaining the quality of the
  fit.  The R factor, however, is independent of the choice of sigma and
  should be a good criteria for judging a fit.

  The merit of using a value of sigma that assures unit chi-square is
  that the error bars on the variables will be correctly normalized.  If
  the fit is of acceptable quality, than the error bars reported in the
  log file will be those for a variable that is normally distributed
  about its best-fit value.

  Since there is no signal processing involved in Phit, there is no way
  to evaluate the number of independent measurements in the data.  The
  standard assumption in this situation is that each input data point is
  an independent measurement.  Chi-square is normalized under this
  assumption.  Phit assumes the number of independent points is the
  number of data points falling within the fitting ranges minus the
  number of guess values.

  Whatever evaluation of sigma is used, chi-square is calculated from
  the residual at each point weighted by the appropriate value of sigma,
  as in Eq. 5.2 of the Feffit document.  This value of chi-square is
  then used in calculating error bars and correlations between
  variables.  The normalized chi-square reported in phit.log is this
  chi-square divided by the number of independent points.

  The error bars on the guess values are calculated assuming the fitting
  function is normally distributed about the best-fit values.  With this
  assumption, the error bars reported are one-sigma values for the
  variation in the guessed variables.  Error bars for the evaluation of
  set expressions are also reported in phit.log.  These are propagated
  numerically from the error bars in the guessed variables and include
  the correlation terms.  See page ?? in Bevington's book for the
  details of this calculation.  Error bars are reported neither for set
  expressions that are independent of guessed variables nor for set
  expressions that depend on the x-axis.

  Please read Chapter 5 of the Feffit document carefully.  It is a good
  discussion of the issues of non-linear minimization and provides
  information on interpreting the results of the error analysis
  performed by Phit.

  7.  Acknowledgments, References, and Program Notes

  7.1.  Acknowledgments

  I mostly want to thank Matt Newville.  He suggested writing the
  program in this manner and offered me several subroutines from Feffit
  for my use here.  Matt and Daniel Haskel helped me test the code from
  its earliest incarnations.

  7.2.  Bibliography

  1. Bevington, Philip R., Data Reduction and Error Analysis for the
     Physical Sciences, McGraw-Hill, New York, (1969)

  2. <it/Netlib/ software archive, AT&T

  3. Newville, M, Documentation for Feffit, <sf/Feffit/, UWXAFS Project.

  4. Press, W.H., S.A. Teukolsky, W.T. Vettering, B.P. Flannery
     Numerical Recipes in Fortran, The Art of Scientific Programming,
     Cambridge University Press, (1992)

  7.3.  Copyright Issues

  Phit uses the MINPACK package of subroutines from AT&T's Netlib
  repository.  This is freely available software.  Several other
  algorithms are taken from Numerical Recipes by Press, et al.  By the
  terms stated in that book, the algorithms contained therein are freely
  available to anyone who transcribes them.  The rest of routines in
  Phit are copyright of the University of Washington.  Version numbers
  below 1.0 are not licensed software, but are only released to holders
  of the UWXAFS3.0 software license.  The terms of that agreement apply.

  7.4.  Obtaining New Copies of FEFF or of the UWXAFS Analysis Programs

  If you do not have a license to use FEFF or the UWXAFS analysis
  programs and are interested in obtaining one contact:

  Ed Stern
  c/o UWXAFS Project
  University of Washington
  Department of Physics, FM-15
  Seattle WA, 98195, USA
  phone: (206) 543-2023
  fax: (206) 543-0635
  electronic mail: stern@phys.washington.edu
  URL: http://krazy.phys.washington.edu/people/ed.html

  or

  John Rehr
  c/o FEFF Project
  University of Washington
  Department of Physics, FM-15
  Seattle WA, 98195, USA
  phone: (206) 543-8593
  fax: (206) 543-0635
  electronic mail: jjr@phys.washington.edu
  URL: http://pauli.phys.washington.edu/~jjr/

  You should request copies of the licensing agreements for FEFF and the
  UWXAFS programs.  These are licensed separately.  ATOMS is distributed
  with both packages.

  7.5.  To Do

  o  Zeros of functions.

  o  Check that guess values are used (explicitly or implicitly) in
     functions.

  o  Add more line shapes, possibly integer factorial, Bessel's
     functions, Legendre polynomial, Hermite polynomials, Gamma
     function, Airy integrals, erf and erfc, Sine and Cosine Integrals,
     etc., etc, etc.  minimized using named columns.

  o  Complex valued data and line shapes (ugh!)

  o  Crystallography applications.

  o  Improve quality of log file.

  o  Update appendix of this document.

  If you have any good suggestions for expanding the functionality of
  Phit, please contact the author.

  7.6.  Source Code Parameters

  Phit is shipped with the following hard-wired parameters:

             parameter (ndatx=2**13, nrangx=10, ndocx=19)
             parameter (ntitx=19, nfunx=100, nconx=300)
             parameter (nguesx=50, nsetx=300)

  These parameters are defined as follows:

  1. ndatx:  max number of input data points

  2. nrangx: max number of fitting range delimiters in input data

  3. ndocx:  max number of documents in i/o data

  4. ntitx:  max number of title lines

  5. nfunx:  max number of input functions

  6. nconx:  max number of constants to be encoded

  7. nguesx: max number of guessed values

  8. nsetx:  max number of set values

     If any of these are too small, they can be changed in the source
     code and the source code can be recompiled.
  7.7.  Code Portability and Code Compilation

  The 1977 ANSI Standard for Fortran has been followed closely, so that
  Phit should easily compile on any machine and run without any
  problems.  The only significant departures from Fortran 77 are the
  assumption of the ASCII character set and the use of integer*2
  variables for the UWXAFS binary file handling routines.

  There are, unfortunately, aspects of Fortran which are machine- and
  compiler-dependent by design.  One such aspect occurs in Phit in the
  form of a compiler-dependent dimension for the ``word-length'' of the
  data in the UWXAFS binary files.  The code cannot easily be made truly
  standard without significant changes to the UWXAFS binary file
  handling routines.  The distributed code will, however, work on most
  machines, with the notable exception of a Vax or Alpha running VMS.
  Changing the second executable statement of Phit from vaxflg = .false.
  to vaxflg = .true. will optimize the code for a VMS machine.

  The UWXAFS binary file handling routines also use character strings
  which are 2048 characters long.  Though standard, some compilers need
  to be told to accept character strings this long.  The notable example
  of such a compiler is xlf (for AIX, IBM's Unix flavor), which needs
  the compiler switch -qcharlen=2048.  While compiling on any machine,
  we recommend including some form of array bounds checking.  If you
  have any problems with the compilation, it may be worthwhile to turn
  off compiler optimization flags.  There may be some persistent, benign
  compiler warnings when you compile Phit.  There may also be
  ``comparison is always false'' warnings when using f2c.  These can
  both be safely ignored.

  7.8.  Adding More Data Formats to Phit

  If the two data file formats (UWXAFS, ASCII) are not acceptable or
  convenient to your needs (that is, if you prefer using some other
  format), other choices could be added with a minimal amount of coding.
  The input and output of data files is fairly well-isolated, with
  subroutine inpdat and outdat controlling which data format to use.  If
  you'd like another file format either contact us about it or follow
  the example of the routines inpcol and outcol, which read and write
  files in the ASCII column data format.

  7.9.  About this document.

  This document was composed using a mark-up language called linuxdoc-
  sgml.  This is the documentation standard of the Linux Documentation
  Project.  linuxdoc-sgml is an adaptation of the QWERTZ document type
  definition written by Tom Gordon.  linuxdoc-sgml is available on the
  net.

  The value of a Standard Generalized Markup Language (SGML) is that it
  can be processed into any number of formats from a common source.
  Using linuxdoc-sgml, a single marked up file can be used to produce
  LaTeX, PostScript, plain ASCII, HTML, TeXinfo, or dvi documentation.

  8.  Appendix:  Some Worked Examples

  The examples in this appendix are from version 0.11 of Phit.  Some
  features of these examples might not be consistent with later
  versions.  Chapters 3 and 4 are updated more often than is this
  appendix.

  8.1.  Fitting a Line + a Gaussian + Noise

  This example fits a simple sum of two line shapes, a line and
  Gaussian.  The line has a slope of 3.2 and a y-intercept of -77.1.
  The Gaussian is centered at 55, has a width of 5, and an amplitude of
  886.23.  On top of this was placed noise from a pseudo-random number
  generator with rms amplitude of 7.071.

  Here is the input file for this fitting:

               title = input data is a line + a gaussian + noise
               xaxis = zeta
               data =  noisy.dat               format = ascii
               !x1 = 20        x2 = 80
               all             write = fit

               %==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==

               guess   m               1
               guess   b               1
               guess   e0              54
               guess   amp             12.9
               guess   w               4
               set     line            m*zeta

               func    1       line + b
               id      1       a line!!!

               func    12      amp*gauss(zeta, e0, w)
               id      12      a gaussian

  In this input file, the input data is identified as noisy.dat with the
  keyword data.  The input file format is ASCII.  This need not be
  specified since ASCII input is the default.  Had the data been in a
  UWXAFS file then format=uwxafs would have been specified and the nkey
  or skey would have been provided.  The label for the xaxis is zeta.
  This is used in the math expressions below.  Since the word all is in
  the input file, files containing the best fit line and the best fit
  Gaussian will be written as well as one containing the sum of the line
  and the Gaussian.  The fit will be performed over the entire input
  data range.  Were the x1 and x2 keywords not commented out, the fit
  would include only those points between the values of 20 and 80 on the
  input x axis.

  Five guess values are set.  These correspond to the slope and y-
  intercept of the line and the center, height, and width of the
  Gaussian.  The zeta dependent part of the line is introduced as the
  set value line.  Finally the functions to be summed are defined at the
  bottom of the input file.  Each function has an id line associated
  with it.  Note that the functions do not have to be sequentially
  numbered.

  Here is the data and fit for this example.  (Picture goes here.)

  Here is the log file for this fit:

   ===========================================================================
   PHIT 0.11                                                    by Bruce Ravel
   ===========================================================================

   Data read from: "noisy.dat"

   Titles:
     >  input data is a line + a gaussian + noise

   ===========================================================================

       Number of data points in fit:                     100
       Number of variables:                                5
       Number of unused data points:                      95
       Sigma = standard deviation of residuals:            5.7245
       Reduced chi squared:                                1.0526
       R factor:                                            .0014

   ===========================================================================

   Guess values:

       name                  initial guess   best fit value     uncertainty
   ---------------------------------------------------------------------------
   |   m                            1.0000         3.2032          .0185
   |   b                            1.0000       -76.7160         1.2159
   |   e0                          54.0000        55.1111          .1220
   |   amp                         12.9000       887.1808        29.3860
   |   w                            4.0000         4.9709          .1814
   ---------------------------------------------------------------------------

   Correlations between guess values:

       variable 1             variable 2             correlation
   ---------------------------------------------------------------------------
       b                      m                      =    -.848
       w                      amp                    =     .618
       amp                    b                      =    -.225
   ---------------------------------------------------------------------------
       All other correletions are between .150 and -.150

   ===========================================================================

   The x-axis label is: zeta

       First  fitting range:       1.100 to   110.000

   ===========================================================================

   Set value math expressions:

       name                        value
   ---------------------------------------------------------------------------
       line                     m*zeta
   ---------------------------------------------------------------------------

   ===========================================================================

   Function   1 >  a line!!!
         line+b

   Function  12 >  a gaussian
         amp*gauss(zeta,e0,w)

  You will notice that it did an excellent job determining the values of
  the parameters.  Also the estimation of sigma was a little low, but
  reasonable.  This is a good fit, not only by the excellent
  determination of the parameters, but also by the chi-square and R-
  factor tests.

  What happens if sigdat is set to 7.07, the rms noise value place on
  the data?  Call R is the ratio of sigdat to the sigma from the
  residuals, R = 7.07/5.72 = 1.24.  Normalized chi-square will be
  reduced by a factor of R^2 and the error bars increased by a factor of
  R.

  One final note about this fit.  A good initial guess for e0 was
  needed.  Guessing 45 is a poor enough initial guess that the
  minimization algorithm is unable to determine the best fit.  This is
  because, at values far from the proper center, the gaussian function
  is very insensitive to small changes in value for the center.  Thus
  the algorithm is unable to determine how to change this parameter to
  improve the fit.  Close initial guesses are not always necessary, but
  are often prudent.

  8.2.  Fitting An Einstein Temperature to XAFS Debye-Waller Factors

  A single frequency model for displacement about bond lengths as
  measured by XAFS is usually successful.  In this example, I fit a
  single Einstein temperature to mean square displacements as determined
  from XAFS analysis at 10 temperatures.  The material is the YBCO
  superconductor and the scattering path that produced these data was a
  single scattering path between copper and barium.  Here is the input
  file:

       title = testing einstein
       data cb.dat
       format = ascii          sigma
       xaxis = T       npoints = 50
       title = YBCO data, cu-ba bond

       %==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==

       guess   theta           400
       set     rmass           43.444

       func    1       eins(t, theta, rmass)
       id      1       the einstein model

  The x-axis label is chosen to be t as this is data in temperature.
  The measurement uncertainties are provided in the file cb.dat and will
  be used in the minimization and error analysis.  The Einstein function
  for mean square displacement depends upon temperature, theta (the
  Einstein temperature), and the reduced mass of the two atoms.  In
  Phit, the reduced mass is in atomic units.  Theta is varied to produce
  the best fit.

  Here is the data and fit for this example.  (picture goes here)

  Here is the log file for this fit:

   ===========================================================================
   PHIT 0.11                                                    by Bruce Ravel
   ===========================================================================

   Data read from: "cb.dat"

   Titles:
     >  testing einstein
     >  YBCO data, cu-ba bond

   ===========================================================================

       Number of data points in fit:                      10
       Number of variables:                                1
       Number of unused data points:                       9
       Sigma array provided with data.
       Reduced chi squared:                                 .2639
       R factor:                                            .0050

   ===========================================================================

   Guess values:

       name                  initial guess   best fit value     uncertainty
   ---------------------------------------------------------------------------
   |   theta                      400.0000       217.6208         1.1939
   ---------------------------------------------------------------------------

   ===========================================================================

   The x-axis label is: t

       First  fitting range:      10.000 to   300.000

   ===========================================================================

   Set value math expressions:

       name                        value
   ---------------------------------------------------------------------------
       rmass                         43.4440
   ---------------------------------------------------------------------------

   ===========================================================================

   Function   1 >  the einstein model
         eins(t,theta,rmass)

  This value for theta agrees with other XAFS analysis on this material.
  The fit is a good one by inspection, chi-square, and R-factor.

  8.3.  Fitting the Near Edge Structure of Barium Titanate

  Here is a more difficult problem than the previous two.  This example
  will fit a number of Gaussians and an arctangent to the near edge
  structure of the titanium K-edge absorption in barium titanate.  The
  arctangent is chosen to model the atomic absorption step and the
  Gaussians are chosen to fit the peaks in the near-edge structure.

  Here is the input file:

       title = fitting near edge structure with atan + sum of gaussians
       title = input data is BaTiO3, Ti K edge
       xaxis = e
       data =  ba.nor          format = ascii
       x1 = 4965       x2 = 5000
       write = fit     cormin = 0.5    all

       %==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==

       guess   ampatan         1
       guess   watan           1
       guess   e0              4980

       set     ec1             4969.5
       guess   w1              2
       guess   a1              1

       set     ec2             4973.5
       guess   w2              2
       guess   a2              1

       set     ec3             4980.5
       guess   w3              2
       guess   a3              1

       set     ec4             4986
       guess   w4              2
       guess   a4              1

       set     ec5             4993.5
       guess   w5              2
       guess   a5              1

       set     ec6             4998.5
       guess   w6              2
       guess   a6              1

       %==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==

       func    1       ampatan * (atan(watan*(e-e0)) + pi/2)
       id      1       an arctangent

       func    2       a1 * gauss(e, ec1, w1)
       id      2       gaussian #1, e_center=4969.5

       func    3       a2 * gauss(e, ec2, w2)
       id      3       gaussian #2, e_center=4973.5

       func    4       a3 * gauss(e, ec3, w3)
       id      4       gaussian #3, e_center=4980.5

       func    5       a4 * gauss(e, ec4, w4)
       id      5       gaussian #4, e_center=4986

       func    6       a5*gauss(e, ec5, w5)
       id      6       gaussian #5, e_center=4993.5

       func    7       a6*gauss(e, ec6, w6)
       id      7       gaussian #6, e_center=4998.5

  The fitting range is limited by the keywords x1 and x2.  The output
  data will be written only over the fitting range, as specified by the
  keyword write.  Since the data is an entire XAFS scan and extends for
  hundreds of eV below and above the edge, it would be unnecessary to
  write the fit out to the full data range.  All of the individual
  functions will be written to data files.

  My variables include the width, center, and amplitude of the
  arctangent and the widths and amplitudes of the gaussians.  I have
  fixed the centers of the gaussians at the energy value of the highest
  point of each peak in the data set.  Note in the picture below that
  the energy scale of this scan is shifted relative to the edge energy
  of titanium.  McMaster reports the titanium K edge energy as 4966 eV.
  In this scan the edge energy is about 4980.  This most likely means
  that the monochromator software was reporting a constant offset when
  translating monochromator encoder readings into energy values.  This
  doesn't effect the analysis in any way.

  Here is the data, fit, and individual functions for this example:
  (picture goes here)

  Here is the log file:

   ===========================================================================
   PHIT 0.11                                                    by Bruce Ravel
   ===========================================================================

   Data read from: "ba.nor"

   Titles:
     >  fitting near edge structure with atan + sum of gauss
     >  input data is BaTiO3, Ti K edge

   ===========================================================================

       Number of data points in fit:                      71
       Number of variables:                               15
       Number of unused data points:                      56
       Sigma = standard deviation of residuals:             .0190
       Reduced chi squared:                                1.2706
       R factor:                                        .4641E-03

   ===========================================================================

   Guess values:

       name                  initial guess   best fit value     uncertainty
   ---------------------------------------------------------------------------
   |   ampatan                      1.0000          .3314          .0327
   |   watan                        1.0000          .4251          .0244
   |   e0                        4980.0000      4979.8408         2.3025
   |   w1                           2.0000          .9055          .1405
   |   a1                           1.0000          .2407          .0353
   |   w2                           2.0000         2.5543          .4258
   |   a2                           1.0000          .5403          .0900
   |   w3                           2.0000          .8335          .1101
   |   a3                           1.0000          .2745          .0354
   |   w4                           2.0000         1.7055          .0503
   |   a4                           1.0000         2.2086          .0809
   |   w5                           2.0000         1.7905          .2463
   |   a5                           1.0000          .5889          .1365
   |   w6                           2.0000         3.6052          .5544
   |   a6                           1.0000         1.6088          .2232
   ---------------------------------------------------------------------------

   Correlations between guess values:

       variable 1             variable 2             correlation
   ---------------------------------------------------------------------------
       e0                     ampatan                =     .992
       a5                     w5                     =     .852
       w6                     a5                     =    -.839
       a2                     w2                     =     .829
       a4                     w4                     =     .826
       a2                     watan                  =     .759
       a6                     w6                     =     .754
       a3                     w3                     =     .681
       a1                     w1                     =     .667
       w6                     w5                     =    -.612
       w2                     watan                  =     .605
       a6                     a5                     =    -.602
       a4                     a3                     =     .556
       a5                     a4                     =     .546
       w5                     a4                     =     .523
       w2                     a1                     =    -.513
       a6                     ampatan                =    -.500
   ---------------------------------------------------------------------------
       All other correletions are between .500 and -.500
   ===========================================================================

   The x-axis label is: e

       First  fitting range:    4965.000 to  5000.000

   ===========================================================================

   Set value math expressions:

       name                        value
   ---------------------------------------------------------------------------
       ec1                         4969.5000
       ec2                         4973.5000
       ec3                         4980.5000
       ec4                         4986.0000
       ec5                         4993.5000
       ec6                         4998.5000
   ---------------------------------------------------------------------------

   ===========================================================================

   Function   1 >  an arctangent
         ampatan*(atan(watan*(e-e0))+pi/2)

   Function   2 >  gaussian #1, e_center=4969.5
         a1*gauss(e,ec1,w1)

   Function   3 >  gaussian #2, e_center=4973.5
         a2*gauss(e,ec2,w2)

   Function   4 >  gaussian #3, e_center=4980.5
         a3*gauss(e,ec3,w3)

   Function   5 >  gaussian #4, e_center=4986
         a4*gauss(e,ec4,w4)

   Function   6 >  gaussian #5, e_center=4993.5
         a5*gauss(e,ec5,w5)

   Function   7 >  gaussian #6, e_center=4998.5
         a6*gauss(e,ec6,w6)

  This seems to be a good fit.  The R-factor is very low, indicating a
  small misfit relative to the size of the data.  The chi-square is
  nearly 1, which is expected since the standard deviation of the
  residual array was used as the measurement uncertainty.

  The value for e0, the center of the arctangent seems to be a
  reasonable measure for the edge energy on this shifted scale.  It is
  reasonable to call that point in the data the edge energy within the
  1.4 eV uncertainty that Phit found.

  You will notice in the correlations table that the sixth Gaussian and
  the arctangent are highly correlated.  This is reasonable considering
  that the fitting range that I chose (in order to illustrate this
  point) ends within a half-width of the peak of the sixth Gaussian.
  Thus the parameters describing this Gaussian are rather poorly
  determined and are very sensitive to the baseline determined by the
  height and placement of the arctangent.

