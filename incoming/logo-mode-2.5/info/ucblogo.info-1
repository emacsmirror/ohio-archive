This is Info file ucblogo.info, produced by Makeinfo version 1.67 from
the input file ucble-4.3.0.texi.


File: ucblogo.info,  Node: Top,  Up: (dir)

This is a TeXinfo version of Berkeley Logo User Manual

Original written by: Brian Harvey

* Menu:

* INTRODUCTION::
* DATA STRUCTURE PRIMITIVES::
* COMMUNICATION::
* ARITHMETIC::
* LOGICAL OPERATIONS::
* GRAPHICS::
* WORKSPACE MANAGEMENT::
* CONTROL STRUCTURES::
* MACROS::
* ERROR PROCESSING::
* SPECIAL VARIABLES::
* INDEX::


File: ucblogo.info,  Node: INTRODUCTION,  Next: DATA STRUCTURE PRIMITIVES,  Up: Top

Introduction
************

* Menu:

* OVERVIEW::
* ENTERING AND LEAVING LOGO::
* TOKENIZATION::


File: ucblogo.info,  Node: OVERVIEW,  Next: ENTERING AND LEAVING LOGO,  Up: INTRODUCTION

Overview
========

Copyright (C) 1993 by the Regents of the University of California

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at your
option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
675 Mass Ave, Cambridge, MA 02139, USA.

This is a program that is still being written.  Many things are missing,
including adequate documentation.  This manual assumes that you already
know how to program in Logo, and merely presents the details of this new
implementation.

Read Computer_Science_Logo_Style, Volume_1:_ _Symbolic_Computing_ by
Brian Harvey (MIT Press, 1997) for a tutorial on Logo programming with
emphasis on symbolic computation.

Here are the special features of this dialect of Logo:


     Source file compatible among Unix, DOS, and Mac platforms.
     
     Random-access arrays.
     
     Variable number of inputs to user-defined procedures.
     
     Mutators for list structure (dangerous).
     
     Pause on error, and other improvements to error handling.
     
     Comments and continuation lines; formatting is preserved when
     procedure definitions are saved or edited.
     
     Terrapin-style tokenization (e.g., [2+3] is a list with one member)
     but LCSI-style syntax (no special forms except TO).  The best of
     both worlds.
     
     First-class instruction and expression templates (see APPLY).
     
     Macros.

Features *not* found in Berkeley Logo include robotics, music, GUIs,
animation, parallelism, and multimedia.  For those, buy a commercial
version.


File: ucblogo.info,  Node: ENTERING AND LEAVING LOGO,  Next: TOKENIZATION,  Prev: OVERVIEW,  Up: INTRODUCTION

Entering and Leaving Logo
=========================

The process to start Logo depends on your operating system:

`Unix:'
     Type the word logo to the shell.  (The directory in which you've
     installed Logo must be in your path.)

`DOS:'
     Change directories to the one containing Logo (probably
     C:\UCBLOGO).  Then type UCBLOGO for the large memory version, or
     BL for the 640K version.

`Mac:'
     Double-click on the LOGO icon within the "UCB Logo" folder.

`Windows:'
     Double-click on the UCBWLOGO icon in the UCBLOGO folder.

To leave Logo, enter the command bye.

Under Unix or DOS, if you include one or more filenames on the command
line when starting Logo, those files will be loaded before the
interpreter starts reading commands from your terminal.  If you load a
file that executes some program that includes a `bye' command, Logo
will run that program and exit.  You can therefore write stand-alone
programs in Logo and run them with shell/batch scripts.  To support
this technique, Logo does not print its usual welcoming and parting
messages if you give file arguments to the logo command.

If you type your interrupt character (see table below) Logo will stop
what it's doing and return to top-level, as if you did THROW "TOPLEVEL.
If you type your quit character Logo will pause as if you did PAUSE.

                     Unix           DOS/Windows          Mac
     
     toplevel    usually ctrl-C       ctrl-Q      command-. (period)
     
     pause       usually ctrl-\       ctrl-W      command-, (comma)

If you have an environment variable called LOGOLIB whose value is the
name of a directory, then Logo will use that directory instead of the
default library.  If you invoke a procedure that has not been defined,
Logo first looks for a file in the current directory named proc.lg
where `proc' is the procedure name in lower case letters.  If such a
file exists, Logo loads that file.  If the missing procedure is still
undefined, or if there is no such file, Logo then looks in the library
directory for a file named proc (no `.lg') and, if it exists, loads it.
If neither file contains a definition for the procedure, then Logo
signals an error.  Several procedures that are primitive in most
versions of Logo are included in the default library, so if you use a
different library you may want to include some or all of the default
library in it.


File: ucblogo.info,  Node: TOKENIZATION,  Prev: ENTERING AND LEAVING LOGO,  Up: INTRODUCTION

Tokenization
============

Names of procedures, variables, and property lists are
case-insensitive.  So are the special words END, TRUE, and FALSE.  Case
of letters is preserved in everything you type, however.

Within square brackets, words are delimited only by spaces and square
brackets.  [2+3] is a list containing one word.  Note, however, that the
Logo primitives that interpret such a list as a Logo instruction or
expression (RUN, IF, etc.) reparse the list as if it had not been typed
inside brackets.

After a quotation mark outside square brackets, a word is delimited by
a space, a square bracket, or a parenthesis.

A word not after a quotation mark or inside square brackets is delimited
by a space, a bracket, a parenthesis, or an infix operator +-*/=<>.
Note that words following colons are in this category.  Note that quote
and colon are not delimiters.

A word consisting of a question mark followed by a number (e.g., ?37),
when runparsed (i.e., where a procedure name is expected), is treated
as if it were the sequence

     ( ? 37 )

making the number an input to the ? procedure.  (See the discussion of
templates, below.)  This special treatment does not apply to words read
as data, to words with a non-number following the question mark, or if
the question mark is backslashed.

A line (an instruction line or one read by READLIST or READWORD) can be
continued onto the following line if its last character is a tilde (~).
READWORD preserves the tilde and the newline; READLIST does not.

An instruction line or a line read by READLIST (but not by READWORD) is
automatically continued to the next line, as if ended with a tilde, if
there are unmatched brackets, parentheses, braces, or vertical bars
pending.  However, it's an error if the continuation line contains only
the word END; this is to prevent runaway procedure definitions.  Lines
explicitly continued with a tilde avoid this restriction.

If a line being typed interactively on the keyboard is continued, either
with a tilde or automatically, Logo will display a tilde as a prompt
character for the continuation line.

A semicolon begins a comment in an instruction line.  Logo ignores
characters from the semicolon to the end of the line.  A tilde as the
last character still indicates a continuation line, but not a
continuation of the comment.  For example, typing the instruction

     print "abc;comment ~
     def

will print the word abcdef.  Semicolon has no special meaning in data
lines read by READWORD or READLIST, but such a line can later be
reparsed using RUNPARSE and then comments will be recognized.

To include an otherwise delimiting character (including semicolon or
tilde) in a word, precede it with backslash (\).  If the last character
of a line is a backslash, then the newline character following the
backslash will be part of the last word on the line, and the line
continues onto the following line.  To include a backslash in a word,
use \\.  If the combination backslash-newline is entered at the
terminal, Logo will issue a backslash as a prompt character for the
continuation line.  All of this applies to data lines read with
READWORD or READLIST as well as to instruction lines.  A character
entered with backslash is EQUALP to the same character without the
backslash, but can be distinguished by the BACKSLASHEDP predicate.
(However, BACKSLASHEDP recognizes backslashedness only on characters for
which it is necessary: whitespace, parentheses, brackets, infix
operators, backslash, vertical bar, tilde, quote, question mark, colon,
and semicolon.)

An alternative notation to include otherwise delimiting characters in
words is to enclose a group of characters in vertical bars.  All
characters between vertical bars are treated as if they were letters.
In data read with READWORD the vertical bars are preserved in the
resulting word.  In data read with READLIST (or resulting from a PARSE
or RUNPARSE of a word) the vertical bars do not appear explicitly; all
potentially delimiting characters (including spaces, brackets,
parentheses, and infix operators) appear as though entered with a
backslash.  Within vertical bars, backslash may still be used; the only
characters that must be backslashed in this context are backslash and
vertical bar themselves.

Characters entered between vertical bars are forever special, even if
the word or list containing them is later reparsed with PARSE or
RUNPARSE.  Characters typed after a backslash are treated somewhat
differently:  When a quoted word containing a backslashed character is
runparsed, the backslashed character loses its special quality and acts
thereafter as if typed normally.  This distinction is important only if
you are building a Logo expression out of parts, to be RUN later, and
want to use parentheses.  For example,

     PRINT RUN (SE "\( 2 "+ 3 "\))

will print 5, but

     RUN (SE "MAKE ""|(| 2)

will create a variable whose name is open-parenthesis.  (Each example
would fail if vertical bars and backslashes were interchanged.)


File: ucblogo.info,  Node: DATA STRUCTURE PRIMITIVES,  Next: COMMUNICATION,  Prev: INTRODUCTION,  Up: Top

Data Structure Primitives
*************************

* Menu:

* CONSTRUCTORS::
* SELECTORS::
* MUTATORS::
* PREDICATES::
* QUERIES::


File: ucblogo.info,  Node: CONSTRUCTORS,  Next: SELECTORS,  Up: DATA STRUCTURE PRIMITIVES

Constructors
============

* Menu:

* WORD::
* LIST::
* SENTENCE::
* FPUT::
* LPUT::
* ARRAY::
* MDARRAY::
* LISTTOARRAY::
* ARRAYTOLIST::
* COMBINE::
* REVERSE::
* GENSYM::


File: ucblogo.info,  Node: WORD,  Next: LIST,  Up: CONSTRUCTORS

word
----

     WORD word1 word2
     (WORD word1 word2 word3 ...)

outputs a word formed by concatenating its inputs.


File: ucblogo.info,  Node: LIST,  Next: SENTENCE,  Prev: WORD,  Up: CONSTRUCTORS

list
----

     LIST thing1 thing2
     (LIST thing1 thing2 thing3 ...)

outputs a list whose members are its inputs, which can be any Logo datum
(word, list, or array).


File: ucblogo.info,  Node: SENTENCE,  Next: FPUT,  Prev: LIST,  Up: CONSTRUCTORS

sentence
--------

     SENTENCE thing1 thing2
     SE thing1 thing2
     (SENTENCE thing1 thing2 thing3 ...)
     (SE thing1 thing2 thing3 ...)

outputs a list whose members are its inputs, if those inputs are not
lists, or the members of its inputs, if those inputs are lists.


File: ucblogo.info,  Node: FPUT,  Next: LPUT,  Prev: SENTENCE,  Up: CONSTRUCTORS

fput
----

     FPUT thing list

outputs a list equal to its second input with one extra member, the
first input, at the beginning.


File: ucblogo.info,  Node: LPUT,  Next: ARRAY,  Prev: FPUT,  Up: CONSTRUCTORS

lput
----

     LPUT thing list

outputs a list equal to its second input with one extra member, the
first input, at the end.


File: ucblogo.info,  Node: ARRAY,  Next: MDARRAY,  Prev: LPUT,  Up: CONSTRUCTORS

array
-----

     ARRAY size
     (ARRAY size origin)

outputs an array of `size' members (must be a positive integer), each of
which initially is an empty list.  Array members can be selected with
ITEM and changed with SETITEM.  The first member of the array is member
number 1 unless an `origin' input (must be an integer) is given, in
which case the first member of the array has that number as its index.
(Typically 0 is used as the origin if anything.)  Arrays are printed by
PRINT and friends, and can be typed in, inside curly braces; indicate an
origin with {a b c}@0.

*Note ITEM:: ; *Note SETITEM:: ; *Note PRINT::


File: ucblogo.info,  Node: MDARRAY,  Next: LISTTOARRAY,  Prev: ARRAY,  Up: CONSTRUCTORS

mdarray
-------

     MDARRAY sizelist				(library procedure)
     (MDARRAY sizelist origin)

outputs a multi-dimensional array.  The first input must be a list of
one or more positive integers.  The second input, if present, must be a
single integer that applies to every dimension of the array.

Ex: (MDARRAY [3 5] 0) outputs a two-dimensional array whose members
range from [0 0] to [2 4].


File: ucblogo.info,  Node: LISTTOARRAY,  Next: ARRAYTOLIST,  Prev: MDARRAY,  Up: CONSTRUCTORS

listtoarray
-----------

     LISTTOARRAY list				(library procedure)
     (LISTTOARRAY list origin)

outputs an array of the same size as the input list, whose members are
the members of the input list.


File: ucblogo.info,  Node: ARRAYTOLIST,  Next: COMBINE,  Prev: LISTTOARRAY,  Up: CONSTRUCTORS

arraytolist
-----------

     ARRAYTOLIST array				(library procedure)

outputs a list whose members are the members of the input array.  The
first member of the output is the first member of the array, regardless
of the array's origin.


File: ucblogo.info,  Node: COMBINE,  Next: REVERSE,  Prev: ARRAYTOLIST,  Up: CONSTRUCTORS

combine
-------

     COMBINE thing1 thing2				(library procedure)

if thing2 is a word, outputs WORD thing1 thing2.  If thing2 is a list,
outputs FPUT thing1 thing2.

*Note WORD:: ; *Note FPUT::


File: ucblogo.info,  Node: REVERSE,  Next: GENSYM,  Prev: COMBINE,  Up: CONSTRUCTORS

reverse
-------

     REVERSE list					(library procedure)

outputs a list whose members are the members of the input list, in
reverse order.


File: ucblogo.info,  Node: GENSYM,  Prev: REVERSE,  Up: CONSTRUCTORS

gensym
------

     GENSYM						(library procedure)

outputs a unique word each time it's invoked.  The words are of the form
G1, G2, etc.


File: ucblogo.info,  Node: SELECTORS,  Next: MUTATORS,  Prev: CONSTRUCTORS,  Up: DATA STRUCTURE PRIMITIVES

Data Selectors
==============

* Menu:

* FIRST::
* FIRSTS::
* LAST::
* BUTFIRST::
* BUTFIRSTS::
* BUTLAST::
* ITEM::
* MDITEM::
* PICK::
* REMOVE::
* REMDUP::
* QUOTED::


File: ucblogo.info,  Node: FIRST,  Next: FIRSTS,  Up: SELECTORS

first
-----

     FIRST thing

if the input is a word, outputs the first character of the word.  If the
input is a list, outputs the first member of the list.  If the input is
an array, outputs the origin of the array (that is, the INDEX OF the
first member of the array).


File: ucblogo.info,  Node: FIRSTS,  Next: LAST,  Prev: FIRST,  Up: SELECTORS

firsts
------

     FIRSTS list

outputs a list containing the FIRST of each member of the input list.
It is an error if any member of the input list is empty.  (The input
itself may be empty, in which case the output is also empty.)  This
could be written as

     to firsts :list
     output map "first :list
     end

but is provided as a primitive in order to speed up the iteration tools
MAP, MAP.SE, and FOREACH.

     to transpose :matrix
     if emptyp first :matrix [op []]
     op fput firsts :matrix transpose bfs :matrix
     end

*Note MAP:: ; *Note MAPdSE:: ; *Note FOREACH::


File: ucblogo.info,  Node: LAST,  Next: BUTFIRST,  Prev: FIRSTS,  Up: SELECTORS

last
----

     LAST wordorlist

if the input is a word, outputs the last character of the word.  If the
input is a list, outputs the last member of the list.


File: ucblogo.info,  Node: BUTFIRST,  Next: BUTFIRSTS,  Prev: LAST,  Up: SELECTORS

butfirst
--------

     BUTFIRST wordorlist
     BF wordorlist

if the input is a word, outputs a word containing all but the first
character of the input.  If the input is a list, outputs a list
containing all but the first member of the input.


File: ucblogo.info,  Node: BUTFIRSTS,  Next: BUTLAST,  Prev: BUTFIRST,  Up: SELECTORS

butfirsts
---------

     BUTFIRSTS list
     BFS list

outputs a list containing the BUTFIRST of each member of the input list.
It is an error if any member of the input list is empty or an array.
(The input itself may be empty, in which case the output is also empty.)
This could be written as

     to butfirsts :list
     output map "butfirst :list
     end

but is provided as a primitive in order to speed up the iteration tools
MAP, MAP.SE, and FOREACH.

*Note MAP:: ; *Note MAPdSE:: ; *Note FOREACH::


File: ucblogo.info,  Node: BUTLAST,  Next: ITEM,  Prev: BUTFIRSTS,  Up: SELECTORS

butlast
-------

     BUTLAST wordorlist
     BL wordorlist

if the input is a word, outputs a word containing all but the last
character of the input.  If the input is a list, outputs a list
containing all but the last member of the input.


File: ucblogo.info,  Node: ITEM,  Next: MDITEM,  Prev: BUTLAST,  Up: SELECTORS

item
----

     ITEM index thing

if the `thing' is a word, outputs the `index'th character of the word.
If the `thing' is a list, outputs the `index'th member of the list.  If
the `thing' is an array, outputs the `index'th member of the array.
`Index' starts at 1 for words and lists; the starting index of an array
is specified when the array is created.


File: ucblogo.info,  Node: MDITEM,  Next: PICK,  Prev: ITEM,  Up: SELECTORS

mditem
------

     MDITEM indexlist array				(library procedure)

outputs the member of the multidimensional `array' selected by the list
of numbers `indexlist'.


File: ucblogo.info,  Node: PICK,  Next: REMOVE,  Prev: MDITEM,  Up: SELECTORS

pick
----

     PICK list					(library procedure)

outputs a randomly chosen member of the input list.


File: ucblogo.info,  Node: REMOVE,  Next: REMDUP,  Prev: PICK,  Up: SELECTORS

remove
------

     REMOVE thing list				(library procedure)

outputs a copy of `list' with every member equal to `thing' removed.


File: ucblogo.info,  Node: REMDUP,  Next: QUOTED,  Prev: REMOVE,  Up: SELECTORS

remdup
------

     REMDUP list					(library procedure)

outputs a copy of `list' with duplicate members removed.  If two or more
members of the input are equal, the rightmost of those members is the
one that remains in the output.


File: ucblogo.info,  Node: QUOTED,  Prev: REMDUP,  Up: SELECTORS

quoted
------

     QUOTED thing					(library procedure)

outputs its input, if a list; outputs its input with a quotation mark
prepended, if a word.


File: ucblogo.info,  Node: MUTATORS,  Next: PREDICATES,  Prev: SELECTORS,  Up: DATA STRUCTURE PRIMITIVES

Data Mutators
=============

* Menu:

* SETITEM::
* MDSETITEM::
* dSETFIRST::           .SETFIRST
* dSETBF::              .SETBF
* dSETITEM::            .SETITEM
* PUSH::
* POP::
* QUEUE::
* DEQUEUE::


File: ucblogo.info,  Node: SETITEM,  Next: MDSETITEM,  Up: MUTATORS

setitem
-------

     SETITEM index array value

command.  Replaces the `index'th member of `array' with the new `value'.
Ensures that the resulting array is not circular, i.e., `value' may not
be a list or array that contains `array'.


File: ucblogo.info,  Node: MDSETITEM,  Next: dSETFIRST,  Prev: SETITEM,  Up: MUTATORS

mdsetitem
---------

     MDSETITEM indexlist array value			(library procedure)

command.  Replaces the member of `array' chosen by `indexlist' with the
new `value'.


File: ucblogo.info,  Node: dSETFIRST,  Next: dSETBF,  Prev: MDSETITEM,  Up: MUTATORS

.setfirst
---------

     .SETFIRST list value

command.  Changes the first member of `list' to be `value'.

WARNING: Primitives whose names start with a period are DANGEROUS.
Their use by non-experts is not recommended.  The use of .SETFIRST can
lead to circular list structures, which will get some Logo primitives
into infinite loops; unexpected changes to other data structures that
share storage with the list being modified; and the loss of memory if a
circular structure is released.


File: ucblogo.info,  Node: dSETBF,  Next: dSETITEM,  Prev: dSETFIRST,  Up: MUTATORS

.setbf
------

     .SETBF list value

command.  Changes the butfirst of `list' to be `value'.

WARNING: Primitives whose names start with a period are DANGEROUS.
Their use by non-experts is not recommended.  The use of .SETBF can lead
to circular list structures, which will get some Logo primitives into
infinite loops; unexpected changes to other data structures that share
storage with the list being modified; Logo crashes and coredumps if the
butfirst of a list is not itself a list; and the loss of memory if a
circular structure is released.


File: ucblogo.info,  Node: dSETITEM,  Next: PUSH,  Prev: dSETBF,  Up: MUTATORS

.setitem
--------

     .SETITEM index array value

command.  Changes the `index'th member of `array' to be `value', like
SETITEM, but without checking for circularity.

WARNING: Primitives whose names start with a period are DANGEROUS.
Their use by non-experts is not recommended.  The use of .SETITEM can
lead to circular arrays, which will get some Logo primitives into
infinite loops; and the loss of memory if a circular structure is
released.

*Note SETITEM::


File: ucblogo.info,  Node: PUSH,  Next: POP,  Prev: dSETITEM,  Up: MUTATORS

push
----

     PUSH stackname thing				(library procedure)

command.  Adds the `thing' to the stack that is the value of the
variable whose name is `stackname'.  This variable must have a list as
its value; the initial value should be the empty list.  New members are
added at the front of the list.


File: ucblogo.info,  Node: POP,  Next: QUEUE,  Prev: PUSH,  Up: MUTATORS

pop
---

     POP stackname					(library procedure)

outputs the most recently PUSHed member of the stack that is the value
of the variable whose name is `stackname' and removes that member from
the stack.


File: ucblogo.info,  Node: QUEUE,  Next: DEQUEUE,  Prev: POP,  Up: MUTATORS

queue
-----

     QUEUE queuename thing				(library procedure)

command.  Adds the `thing' to the queue that is the value of the
variable whose name is `queuename'.  This variable must have a list as
its value; the initial value should be the empty list.  New members are
added at the back of the list.


File: ucblogo.info,  Node: DEQUEUE,  Prev: QUEUE,  Up: MUTATORS

dequeue
-------

     DEQUEUE queuename				(library procedure)

outputs the least recently QUEUEd member of the queue that is the value
of the variable whose name is `queuename' and removes that member from
the queue.


File: ucblogo.info,  Node: PREDICATES,  Next: QUERIES,  Prev: MUTATORS,  Up: DATA STRUCTURE PRIMITIVES

Predicates
==========

* Menu:

* WORDP::
* LISTP::
* ARRAYP::
* EMPTYP::
* EQUALP::
* BEFOREP::
* dEQ::                 .EQ
* MEMBERP::
* SUBSTRINGP::
* NUMBERP::
* BACKSLASHEDP::


File: ucblogo.info,  Node: WORDP,  Next: LISTP,  Up: PREDICATES

wordp
-----

     WORDP thing
     WORD? thing

outputs TRUE if the input is a word, FALSE otherwise.


File: ucblogo.info,  Node: LISTP,  Next: ARRAYP,  Prev: WORDP,  Up: PREDICATES

listp
-----

     LISTP thing
     LIST? thing

outputs TRUE if the input is a list, FALSE otherwise.


File: ucblogo.info,  Node: ARRAYP,  Next: EMPTYP,  Prev: LISTP,  Up: PREDICATES

arrayp
------

     ARRAYP thing
     ARRAY? thing

outputs TRUE if the input is an array, FALSE otherwise.


File: ucblogo.info,  Node: EMPTYP,  Next: EQUALP,  Prev: ARRAYP,  Up: PREDICATES

emptyp
------

     EMPTYP thing
     EMPTY? thing

outputs TRUE if the input is the empty word or the empty list, FALSE
otherwise.


File: ucblogo.info,  Node: EQUALP,  Next: BEFOREP,  Prev: EMPTYP,  Up: PREDICATES

equalp
------

     EQUALP thing1 thing2
     EQUAL? thing1 thing2
     thing1 = thing2

outputs TRUE if the inputs are equal, FALSE otherwise.  Two numbers are
equal if they have the same numeric value.  Two non-numeric words are
equal if they contain the same characters in the same order.  If there
is a variable named CASEIGNOREDP whose value is TRUE, then an upper case
letter is considered the same as the corresponding lower case letter.
(This is the case by default.)  Two lists are equal if their members are
equal.  An array is only equal to itself; two separately created arrays
are never equal even if their members are equal.  (It is important to be
able to know if two expressions have the same array as their value
because arrays are mutable; if, for example, two variables have the same
array as their values then performing SETITEM on one of them will also
change the other.)

*Note CASEIGNOREDP:: ; *Note SETITEM::


File: ucblogo.info,  Node: BEFOREP,  Next: dEQ,  Prev: EQUALP,  Up: PREDICATES

beforep
-------

     BEFOREP word1 word2
     BEFORE? word1 word2

outputs TRUE if word1 comes before word2 in ASCII collating sequence
(for words of letters, in alphabetical order).  Case-sensitivity is
determined by the value of CASEIGNOREDP.  Note that if the inputs are
numbers, the result may not be the same as with LESSP; for example,
BEFOREP 3 12 is false because 3 collates after 1.

*Note CASEIGNOREDP:: ; *Note LESSP::


File: ucblogo.info,  Node: dEQ,  Next: MEMBERP,  Prev: BEFOREP,  Up: PREDICATES

.eq
---

     .EQ thing1 thing2

outputs TRUE if its two inputs are the same datum, so that applying a
mutator to one will change the other as well.  Outputs FALSE otherwise,
even if the inputs are equal in value.

WARNING: Primitives whose names start with a period are DANGEROUS.
Their use by non-experts is not recommended.  The use of mutators can
lead to circular data structures, infinite loops, or Logo crashes.


File: ucblogo.info,  Node: MEMBERP,  Next: SUBSTRINGP,  Prev: dEQ,  Up: PREDICATES

memberp
-------

     MEMBERP thing1 thing2
     MEMBER? thing1 thing2

if `thing2' is a list or an array, outputs TRUE if `thing1' is EQUALP to
a member of `thing2', FALSE otherwise.  If `thing2' is a word, outputs
TRUE if `thing1' is a one-character word EQUALP to a character of
`thing2', FALSE otherwise.

*Note EQUALP::


File: ucblogo.info,  Node: SUBSTRINGP,  Next: NUMBERP,  Prev: MEMBERP,  Up: PREDICATES

substringp
----------

     SUBSTRINGP thing1 thing2
     SUBSTRING? thing1 thing2

if `thing1' or `thing2' is a list or an array, outputs FALSE.  If
`thing2' is a word, outputs TRUE if `thing1' is EQUALP to a substring of
`thing2', FALSE otherwise.

*Note EQUALP::


File: ucblogo.info,  Node: NUMBERP,  Next: BACKSLASHEDP,  Prev: SUBSTRINGP,  Up: PREDICATES

numberp
-------

     NUMBERP thing
     NUMBER? thing

outputs TRUE if the input is a number, FALSE otherwise.


File: ucblogo.info,  Node: BACKSLASHEDP,  Prev: NUMBERP,  Up: PREDICATES

backslashedp
------------

     BACKSLASHEDP char
     BACKSLASHED? char

outputs TRUE if the input character was originally entered into Logo
with a backslash (\) before it or within vertical bars (|) to prevent
its usual special syntactic meaning, FALSE otherwise.  (Outputs TRUE
only if the character is a backslashed space, tab, newline, or one of
()[]+-*/=<>":;\~?| )


File: ucblogo.info,  Node: QUERIES,  Prev: PREDICATES,  Up: DATA STRUCTURE PRIMITIVES

Queries
=======

* Menu:

* COUNT::
* ASCII::
* RAWASCII::
* CHAR::
* MEMBER::
* LOWERCASE::
* UPPERCASE::
* STANDOUT::
* PARSE::
* RUNPARSE::


File: ucblogo.info,  Node: COUNT,  Next: ASCII,  Up: QUERIES

count
-----

     COUNT thing

outputs the number of characters in the input, if the input is a word;
outputs the number of members in the input, if it is a list or an array.
(For an array, this may or may not be the index of the last member,
depending on the array's origin.)


File: ucblogo.info,  Node: ASCII,  Next: RAWASCII,  Prev: COUNT,  Up: QUERIES

ascii
-----

     ASCII char

outputs the integer (between 0 and 255) that represents the input
character in the ASCII code.  Interprets control characters as
representing backslashed punctuation, and returns the character code for
the corresponding punctuation character without backslash.  (Compare
RAWASCII.)


File: ucblogo.info,  Node: RAWASCII,  Next: CHAR,  Prev: ASCII,  Up: QUERIES

rawascii
--------

     RAWASCII char

outputs the integer (between 0 and 255) that represents the input
character in the ASCII code.  Interprets control characters as
representing themselves.  To find out the ASCII code of an arbitrary
keystroke, use RAWASCII RC.


File: ucblogo.info,  Node: CHAR,  Next: MEMBER,  Prev: RAWASCII,  Up: QUERIES

char
----

     CHAR int

outputs the character represented in the ASCII code by the input, which
must be an integer between 0 and 255.

*Note ASCII::


File: ucblogo.info,  Node: MEMBER,  Next: LOWERCASE,  Prev: CHAR,  Up: QUERIES

member
------

     MEMBER thing1 thing2

if `thing2' is a word or list and if MEMBERP with these inputs would
output TRUE, outputs the portion of `thing2' from the first instance of
`thing1' to the end.  If MEMBERP would output FALSE, outputs the empty
word or list according to the type of `thing2'.  It is an error for
`thing2' to be an array.

*Note MEMBERP::


File: ucblogo.info,  Node: LOWERCASE,  Next: UPPERCASE,  Prev: MEMBER,  Up: QUERIES

lowercase
---------

     LOWERCASE word

outputs a copy of the input word, but with all uppercase letters changed
to the corresponding lowercase letter.


File: ucblogo.info,  Node: UPPERCASE,  Next: STANDOUT,  Prev: LOWERCASE,  Up: QUERIES

uppercase
---------

     UPPERCASE word

outputs a copy of the input word, but with all lowercase letters changed
to the corresponding uppercase letter.


File: ucblogo.info,  Node: STANDOUT,  Next: PARSE,  Prev: UPPERCASE,  Up: QUERIES

standout
--------

     STANDOUT thing

outputs a word that, when printed, will appear like the input but
displayed in standout mode (boldface, reverse video, or whatever your
terminal does for standout).  The word contains terminal-specific magic
characters at the beginning and end; in between is the printed form (as
if displayed using TYPE) of the input.  The output is always a word,
even if the input is of some other type, but it may include spaces and
other formatting characters.  Note: a word output by STANDOUT while Logo
is running on one terminal will probably not have the desired effect if
printed on another type of terminal.

On the Macintosh, the way that standout works is incompatible with the
use of characters whose ASCII code is greater than 127.  Therefore, you
have a choice to make:  The instruction
     CANINVERSE 0
disables standout, but enables the display of ASCII codes above 127, and
the instruction
     CANINVERSE 1
restores the default situation in which standout is enabled and the
extra graphic characters cannot be printed.


File: ucblogo.info,  Node: PARSE,  Next: RUNPARSE,  Prev: STANDOUT,  Up: QUERIES

parse
-----

     PARSE word

outputs the list that would result if the input word were entered in
response to a READLIST operation.  That is, PARSE READWORD has the same
value as READLIST for the same characters read.

*Note READLIST:: ; *Note READWORD::


File: ucblogo.info,  Node: RUNPARSE,  Prev: PARSE,  Up: QUERIES

runparse
--------

     RUNPARSE wordorlist

outputs the list that would result if the input word or list were
entered as an instruction line; characters such as infix operators and
parentheses are separate members of the output.  Note that sublists of a
runparsed list are not themselves runparsed.


File: ucblogo.info,  Node: COMMUNICATION,  Next: ARITHMETIC,  Prev: DATA STRUCTURE PRIMITIVES,  Up: Top

Communication
*************

* Menu:

* TRANSMITTERS::
* RECEIVERS::
* FILE ACCESS::
* TERMINAL ACCESS::


File: ucblogo.info,  Node: TRANSMITTERS,  Next: RECEIVERS,  Up: COMMUNICATION

Transmitters
============

* Menu:

* PRINT::
* TYPE::
* SHOW::

Note:  If there is a variable named PRINTDEPTHLIMIT with a nonnegative
integer value, then complex list and array structures will be printed
only to the allowed depth.  That is, members of members of... of members
will be allowed only so far.  The members omitted because they are just
past the depth limit are indicated by an ellipsis for each one, so a
too-deep list of two members will print as [... ...].

If there is a variable named PRINTWIDTHLIMIT with a nonnegative integer
value, then only the first so many members of any array or list will be
printed.  A single ellipsis replaces all missing data within the
structure.  The width limit also applies to the number of characters
printed in a word, except that a PRINTWIDTHLIMIT between 0 and 9 will
be treated as if it were 10 when applied to words.  This limit applies
not only to the top-level printed datum but to any substructures within
it.

*Note PRINTDEPTHLIMIT:: ; *Note PRINTWIDTHLIMIT::


File: ucblogo.info,  Node: PRINT,  Next: TYPE,  Up: TRANSMITTERS

print
-----

     PRINT thing
     PR thing
     (PRINT thing1 thing2 ...)
     (PR thing1 thing2 ...)

command.  Prints the input or inputs to the current write stream
(initially the terminal).  All the inputs are printed on a single line,
separated by spaces, ending with a newline.  If an input is a list,
square brackets are not printed around it, but brackets are printed
around sublists.  Braces are always printed around arrays.


File: ucblogo.info,  Node: TYPE,  Next: SHOW,  Prev: PRINT,  Up: TRANSMITTERS

type
----

     TYPE thing
     (TYPE thing1 thing2 ...)

command.  Prints the input or inputs like PRINT, except that no newline
character is printed at the end and multiple inputs are not separated by
spaces.  Note: printing to the terminal is ordinarily "line buffered";
that is, the characters you print using TYPE will not actually appear on
the screen until either a newline character is printed (for example, by
PRINT or SHOW) or Logo tries to read from the keyboard (either at the
request of your program or after an instruction prompt).  This buffering
makes the program much faster than it would be if each character
appeared immediately, and in most cases the effect is not disconcerting.
To accommodate programs that do a lot of positioned text display using
TYPE, Logo will force printing whenever SETCURSOR is invoked.  This
solves most buffering problems.  Still, on occasion you may find it
necessary to force the buffered characters to be printed explicitly;
this can be done using the WAIT command.  WAIT 0 will force printing
without actually waiting.

*Note SETCURSOR:: ; *Note WAIT::


File: ucblogo.info,  Node: SHOW,  Prev: TYPE,  Up: TRANSMITTERS

show
----

     SHOW thing
     (SHOW thing1 thing2 ...)

command.  Prints the input or inputs like PRINT, except that if an input
is a list it is printed inside square brackets.

*Note PRINT::


File: ucblogo.info,  Node: RECEIVERS,  Next: FILE ACCESS,  Prev: TRANSMITTERS,  Up: COMMUNICATION

Receivers
=========

* Menu:

* READLIST::
* READWORD::
* READCHAR::
* READCHARS::
* SHELL::


File: ucblogo.info,  Node: READLIST,  Next: READWORD,  Up: RECEIVERS

readlist
--------

     READLIST
     RL

reads a line from the read stream (initially the terminal) and outputs
that line as a list.  The line is separated into members as though it
were typed in square brackets in an instruction.  If the read stream is
a file, and the end of file is reached, READLIST outputs the empty word
(not the empty list).  READLIST processes backslash, vertical bar, and
tilde characters in the read stream; the output list will not contain
these characters but they will have had their usual effect.  READLIST
does not, however, treat semicolon as a comment character.


File: ucblogo.info,  Node: READWORD,  Next: READCHAR,  Prev: READLIST,  Up: RECEIVERS

readword
--------

     READWORD
     RW

reads a line from the read stream and outputs that line as a word.  The
output is a single word even if the line contains spaces, brackets, etc.
If the read stream is a file, and the end of file is reached, READWORD
outputs the empty list (not the empty word).  READWORD processes
backslash, vertical bar, and tilde characters in the read stream.  In
the case of a tilde used for line continuation, the output word DOES
include the tilde and the newline characters, so that the user program
can tell exactly what the user entered.  Vertical bars in the line are
also preserved in the output.  Backslash characters are not preserved in
the output, but the character following the backslash has 128 added to
its representation.  Programs can use BACKSLASHEDP to check for this
code.  (Backslashedness is preserved only for certain characters.)

*Note BACKSLASHEDP::


File: ucblogo.info,  Node: READCHAR,  Next: READCHARS,  Prev: READWORD,  Up: RECEIVERS

readchar
--------

     READCHAR
     RC

reads a single character from the read stream and outputs that character
as a word.  If the read stream is a file, and the end of file is
reached, READCHAR outputs the empty list (not the empty word).  If the
read stream is a terminal, echoing is turned off when READCHAR is
invoked, and remains off until READLIST or READWORD is invoked or a Logo
prompt is printed.  Backslash, vertical bar, and tilde characters have
no special meaning in this context.

*Note READLIST::


File: ucblogo.info,  Node: READCHARS,  Next: SHELL,  Prev: READCHAR,  Up: RECEIVERS

readchars
---------

     READCHARS num
     RCS num

reads `num' characters from the read stream and outputs those characters
as a word.  If the read stream is a file, and the end of file is
reached, READCHARS outputs the empty list (not the empty word).  If the
read stream is a terminal, echoing is turned off when READCHARS is
invoked, and remains off until READLIST or READWORD is invoked or a Logo
prompt is printed.  Backslash, vertical bar, and tilde characters have
no special meaning in this context.

*Note READLIST:: ; *Note READWORD::


File: ucblogo.info,  Node: SHELL,  Prev: READCHARS,  Up: RECEIVERS

shell
-----

     SHELL command
     (SHELL command wordflag)

Under Unix, outputs the result of running `command' as a shell command.
(The command is sent to `/bin/sh', not `csh' or other alternatives.)
If the command is a literal list in the instruction line, and if you
want a backslash character sent to the shell, you must use \\ to get the
backslash through Logo's reader intact.  The output is a list containing
one member for each line generated by the shell command.  Ordinarily
each such line is represented by a list in the output, as though the
line were read using READLIST.  If a second input is given, regardless
of the value of the input, each line is represented by a word in the
output as though it were read with READWORD.  Example:

     to dayofweek
     output first first shell [date]
     end

This is "first first" to extract the first word of the first (and only)
line of the shell output.

Under DOS, SHELL is a command, not an operation; it sends its input to a
DOS command processor but does not collect the result of the command.

The Macintosh, of course, is not programmable.


File: ucblogo.info,  Node: FILE ACCESS,  Next: TERMINAL ACCESS,  Prev: RECEIVERS,  Up: COMMUNICATION

File Access
===========

* Menu:

* OPENREAD::
* OPENWRITE::
* OPENAPPEND::
* OPENUPDATE::
* CLOSE::
* ALLOPEN::
* CLOSEALL::
* ERASEFILE::
* DRIBBLE::
* NODRIBBLE::
* SETREAD::
* SETWRITE::
* READER::
* WRITER::
* SETREADPOS::
* SETWRITEPOS::
* READPOS::
* WRITEPOS::
* EOFP::
* FILEP::


File: ucblogo.info,  Node: OPENREAD,  Next: OPENWRITE,  Up: FILE ACCESS

openread
--------

     OPENREAD filename

command.  Opens the named file for reading.  The read position is
initially at the beginning of the file.


File: ucblogo.info,  Node: OPENWRITE,  Next: OPENAPPEND,  Prev: OPENREAD,  Up: FILE ACCESS

openwrite
---------

     OPENWRITE filename

command.  Opens the named file for writing.  If the file already
existed, the old version is deleted and a new, empty file created.


File: ucblogo.info,  Node: OPENAPPEND,  Next: OPENUPDATE,  Prev: OPENWRITE,  Up: FILE ACCESS

openappend
----------

     OPENAPPEND filename

command.  Opens the named file for writing.  If the file already exists,
the write position is initially set to the end of the old file, so that
newly written data will be appended to it.


File: ucblogo.info,  Node: OPENUPDATE,  Next: CLOSE,  Prev: OPENAPPEND,  Up: FILE ACCESS

openupdate
----------

     OPENUPDATE filename

command.  Opens the named file for reading and writing.  The read and
write position is initially set to the end of the old file, if any.
Note: each open file has only one position, for both reading and
writing.  If a file opened for update is both READER and WRITER at the
same time, then SETREADPOS will also affect WRITEPOS and vice versa.
Also, if you alternate reading and writing the same file, you must
SETREADPOS between a write and a read, and SETWRITEPOS between a read
and a write.

*Note READER:: ; *Note WRITER:: ; *Note SETREADPOS:: ; *Note
SETWRITEPOS::


File: ucblogo.info,  Node: CLOSE,  Next: ALLOPEN,  Prev: OPENUPDATE,  Up: FILE ACCESS

close
-----

     CLOSE filename

command.  Closes the named file.


File: ucblogo.info,  Node: ALLOPEN,  Next: CLOSEALL,  Prev: CLOSE,  Up: FILE ACCESS

allopen
-------

     ALLOPEN

outputs a list whose members are the names of all files currently open.
This list does not include the dribble file, if any.


File: ucblogo.info,  Node: CLOSEALL,  Next: ERASEFILE,  Prev: ALLOPEN,  Up: FILE ACCESS

closeall
--------

     CLOSEALL					(library procedure)

command.  Closes all open files.  Abbreviates FOREACH ALLOPEN [CLOSE ?]

*Note FOREACH:: ; *Note CLOSE::


File: ucblogo.info,  Node: ERASEFILE,  Next: DRIBBLE,  Prev: CLOSEALL,  Up: FILE ACCESS

erasefile
---------

     ERASEFILE filename
     ERF filename

command.  Erases (deletes, removes) the named file, which should not
currently be open.


File: ucblogo.info,  Node: DRIBBLE,  Next: NODRIBBLE,  Prev: ERASEFILE,  Up: FILE ACCESS

dribble
-------

     DRIBBLE filename

command.  Creates a new file whose name is the input, like OPENWRITE,
and begins recording in that file everything that is read from the
keyboard or written to the terminal.  That is, this writing is in
addition to the writing to WRITER.  The intent is to create a transcript
of a Logo session, including things like prompt characters and
interactions.

*Note OPENWRITE:: ; *Note WRITER::


File: ucblogo.info,  Node: NODRIBBLE,  Next: SETREAD,  Prev: DRIBBLE,  Up: FILE ACCESS

nodribble
---------

     NODRIBBLE

command.  Stops copying information into the dribble file, and closes
the file.


File: ucblogo.info,  Node: SETREAD,  Next: SETWRITE,  Prev: NODRIBBLE,  Up: FILE ACCESS

setread
-------

     SETREAD filename

command.  Makes the named file the read stream, used for READLIST, etc.
The file must already be open with OPENREAD or OPENUPDATE.  If the input
is the empty list, then the read stream becomes the terminal, as usual.
Changing the read stream does not close the file that was previously the
read stream, so it is possible to alternate between files.

*Note READLIST:: ; *Note OPENREAD:: ; *Note OPENUPDATE::


File: ucblogo.info,  Node: SETWRITE,  Next: READER,  Prev: SETREAD,  Up: FILE ACCESS

setwrite
--------

     SETWRITE filename

command.  Makes the named file the write stream, used for PRINT, etc.
The file must already be open with OPENWRITE, OPENAPPEND, or OPENUPDATE.
If the input is the empty list, then the write stream becomes the
terminal, as usual.  Changing the write stream does not close the file
that was previously the write stream, so it is possible to alternate
between files.

*Note PRINT:: ; *Note OPENWRITE:: ; *Note OPENAPPEND:: ; *Note
OPENUPDATE::


File: ucblogo.info,  Node: READER,  Next: WRITER,  Prev: SETWRITE,  Up: FILE ACCESS

reader
------

     READER

outputs the name of the current read stream file, or the empty list if
the read stream is the terminal.


File: ucblogo.info,  Node: WRITER,  Next: SETREADPOS,  Prev: READER,  Up: FILE ACCESS

writer
------

     WRITER

outputs the name of the current write stream file, or the empty list if
the write stream is the terminal.


File: ucblogo.info,  Node: SETREADPOS,  Next: SETWRITEPOS,  Prev: WRITER,  Up: FILE ACCESS

setreadpos
----------

     SETREADPOS charpos

command.  Sets the file pointer of the read stream file so that the next
READLIST, etc., will begin reading at the `charpos'th character in the
file, counting from 0.  (That is, SETREADPOS 0 will start reading from
the beginning of the file.)  Meaningless if the read stream is the
terminal.

*Note READLIST::


File: ucblogo.info,  Node: SETWRITEPOS,  Next: READPOS,  Prev: SETREADPOS,  Up: FILE ACCESS

setwritepos
-----------

     SETWRITEPOS charpos

command.  Sets the file pointer of the write stream file so that the
next PRINT, etc., will begin writing at the `charpos'th character in the
file, counting from 0.  (That is, SETWRITEPOS 0 will start writing from
the beginning of the file.)  Meaningless if the write stream is the
terminal.

*Note PRINT::


File: ucblogo.info,  Node: READPOS,  Next: WRITEPOS,  Prev: SETWRITEPOS,  Up: FILE ACCESS

readpos
-------

     READPOS

outputs the file position of the current read stream file.


File: ucblogo.info,  Node: WRITEPOS,  Next: EOFP,  Prev: READPOS,  Up: FILE ACCESS

writepos
--------

     WRITEPOS

outputs the file position of the current write stream file.


File: ucblogo.info,  Node: EOFP,  Next: FILEP,  Prev: WRITEPOS,  Up: FILE ACCESS

eofp
----

     EOFP
     EOF?

predicate, outputs TRUE if there are no more characters to be read in
the read stream file, FALSE otherwise.


File: ucblogo.info,  Node: FILEP,  Prev: EOFP,  Up: FILE ACCESS

filep
-----

     FILEP filename
     FILE? filename					(library procedure)

predicate, outputs TRUE if a file of the specified name exists and can
be read, FALSE otherwise.


File: ucblogo.info,  Node: TERMINAL ACCESS,  Prev: FILE ACCESS,  Up: COMMUNICATION

Terminal Access
===============

* Menu:

* KEYP::
* CLEARTEXT::
* SETCURSOR::
* CURSOR::
* SETMARGINS::
* SETTEXTCOLOR::


File: ucblogo.info,  Node: KEYP,  Next: CLEARTEXT,  Up: TERMINAL ACCESS

keyp
----

     KEYP
     KEY?

predicate, outputs TRUE if there are characters waiting to be read from
the read stream.  If the read stream is a file, this is equivalent to
NOT EOFP.  If the read stream is the terminal, then echoing is turned
off and the terminal is set to CBREAK (character at a time instead of
line at a time) mode.  It remains in this mode until some line-mode
reading is requested (e.g., READLIST).  The Unix operating system
forgets about any pending characters when it switches modes, so the
first KEYP invocation will always output FALSE.

*Note EOFP:: ; *Note READLIST::


File: ucblogo.info,  Node: CLEARTEXT,  Next: SETCURSOR,  Prev: KEYP,  Up: TERMINAL ACCESS

cleartext
---------

     CLEARTEXT
     CT

command.  Clears the text screen of the terminal.


File: ucblogo.info,  Node: SETCURSOR,  Next: CURSOR,  Prev: CLEARTEXT,  Up: TERMINAL ACCESS

setcursor
---------

     SETCURSOR vector

command.  The input is a list of two numbers, the x and y coordinates of
a screen position (origin in the upper left corner, positive direction
is southeast).  The screen cursor is moved to the requested position.
This command also forces the immediate printing of any buffered
characters.


File: ucblogo.info,  Node: CURSOR,  Next: SETMARGINS,  Prev: SETCURSOR,  Up: TERMINAL ACCESS

cursor
------

     CURSOR

outputs a list containing the current x and y coordinates of the screen
cursor.  Logo may get confused about the current cursor position if,
e.g., you type in a long line that wraps around or your program prints
escape codes that affect the terminal strangely.


File: ucblogo.info,  Node: SETMARGINS,  Next: SETTEXTCOLOR,  Prev: CURSOR,  Up: TERMINAL ACCESS

setmargins
----------

     SETMARGINS vector

command.  The input must be a list of two numbers, as for SETCURSOR.
The effect is to clear the screen and then arrange for all further
printing to be shifted down and to the right according to the indicated
margins.  Specifically, every time a newline character is printed
(explicitly or implicitly) Logo will type x_margin spaces, and on every
invocation of SETCURSOR the margins will be added to the input x and y
coordinates.  (CURSOR will report the cursor position relative to the
margins, so that this shift will be invisible to Logo programs.)  The
purpose of this command is to accommodate the display of terminal
screens in lecture halls with inadequate TV monitors that miss the top
and left edges of the screen.

*Note SETCURSOR::


File: ucblogo.info,  Node: SETTEXTCOLOR,  Prev: SETMARGINS,  Up: TERMINAL ACCESS

settextcolor
------------

     SETTEXTCOLOR foreground background
     SETTC foreground background

Command (Windows and DOS extended only).  The inputs are color numbers,
as for turtle graphics.  Future printing to the text window will use the
specified colors for foreground (the characters printed) and background
(the space under those characters).  Using STANDOUT will revert to the
default text window colors.  In the DOS extended (ucblogo.exe) version,
colors in textscreen mode are limited to numbers 0-7, and the coloring
applies only to text printed by the program, not to the echoing of text
typed by the user.  Neither limitation applies to the text portion of
splitscreen mode, which is actually drawn as graphics internally.

*Note STANDOUT::

