This is Info file ucblogo.info, produced by Makeinfo version 1.67 from
the input file ucble-4.3.0.texi.


File: ucblogo.info,  Node: ARITHMETIC,  Next: LOGICAL OPERATIONS,  Prev: COMMUNICATION,  Up: Top

Arithmetic
**********

* Menu:

* NUMERIC OPERATIONS::
* NUMERIC PREDICATES::
* RANDOM NUMBERS::
* PRINT FORMATTING::
* BITWISE OPERATIONS::


File: ucblogo.info,  Node: NUMERIC OPERATIONS,  Next: NUMERIC PREDICATES,  Up: ARITHMETIC

Numeric Operations
==================

* Menu:

* SUM::
* DIFFERENCE::
* MINUS::
* PRODUCT::
* QUOTIENT::
* REMAINDER::
* MODULO::
* INT::
* ROUND::
* SQRT::
* POWER::
* EXP::
* LOG10::
* LN::
* SIN::
* RADSIN::
* COS::
* RADCOS::
* ARCTAN::
* RADARCTAN::
* ISEQ::
* RSEQ::


File: ucblogo.info,  Node: SUM,  Next: DIFFERENCE,  Up: NUMERIC OPERATIONS

sum
---

     SUM num1 num2
     (SUM num1 num2 num3 ...)
     num1 + num2

outputs the sum of its inputs.


File: ucblogo.info,  Node: DIFFERENCE,  Next: MINUS,  Prev: SUM,  Up: NUMERIC OPERATIONS

difference
----------

     DIFFERENCE num1 num2
     num1 - num2

outputs the difference of its inputs.  Minus sign means infix difference
in ambiguous contexts (when preceded by a complete expression), unless
it is preceded by a space and followed by a nonspace.


File: ucblogo.info,  Node: MINUS,  Next: PRODUCT,  Prev: DIFFERENCE,  Up: NUMERIC OPERATIONS

minus
-----

     MINUS num
     - num

outputs the negative of its input.  Minus sign means unary minus if it
is immediately preceded by something requiring an input, or preceded by
a space and followed by a nonspace.  There is a difference in binding
strength between the two forms:

     MINUS 3 + 4     means   -(3+4)
     - 3 + 4         means   (-3)+4


File: ucblogo.info,  Node: PRODUCT,  Next: QUOTIENT,  Prev: MINUS,  Up: NUMERIC OPERATIONS

product
-------

     PRODUCT num1 num2
     (PRODUCT num1 num2 num3 ...)
     num1 * num2

outputs the product of its inputs.


File: ucblogo.info,  Node: QUOTIENT,  Next: REMAINDER,  Prev: PRODUCT,  Up: NUMERIC OPERATIONS

quotient
--------

     QUOTIENT num1 num2
     (QUOTIENT num)
     num1 / num2

outputs the quotient of its inputs.  The quotient of two integers is an
integer if and only if the dividend is a multiple of the divisor.  (In
other words, QUOTIENT 5 2 is 2.5, not 2, but QUOTIENT 4 2 is 2, not 2.0
-- it does the right thing.)  With a single input, QUOTIENT outputs the
reciprocal of the input.


File: ucblogo.info,  Node: REMAINDER,  Next: MODULO,  Prev: QUOTIENT,  Up: NUMERIC OPERATIONS

remainder
---------

     REMAINDER num1 num2

outputs the remainder on dividing `num1' by `num2'; both must be
integers and the result is an integer with the same sign as num1.


File: ucblogo.info,  Node: MODULO,  Next: INT,  Prev: REMAINDER,  Up: NUMERIC OPERATIONS

modulo
------

     MODULO num1 num2

outputs the remainder on dividing `num1' by `num2'; both must be
integers and the result is an integer with the same sign as num2.


File: ucblogo.info,  Node: INT,  Next: ROUND,  Prev: MODULO,  Up: NUMERIC OPERATIONS

int
---

     INT num

outputs its input with fractional part removed, i.e., an integer with
the same sign as the input, whose absolute value is the largest integer
less than or equal to the absolute value of the input.

Note:  Inside the computer numbers are represented in two different
forms, one for integers and one for numbers with fractional parts.
However, on most computers the largest number that can be represented
in integer format is smaller than the largest integer that can be
represented (even with exact precision) in floating-point (fraction)
format.  The INT operation will always output a number whose value is
mathematically an integer, but if its input is very large the output
may not be in integer format.  In that case, operations like REMAINDER
that require an integer input will not accept this number.

*Note REMAINDER::


File: ucblogo.info,  Node: ROUND,  Next: SQRT,  Prev: INT,  Up: NUMERIC OPERATIONS

round
-----

     ROUND num

outputs the nearest integer to the input.


File: ucblogo.info,  Node: SQRT,  Next: POWER,  Prev: ROUND,  Up: NUMERIC OPERATIONS

sqrt
----

     SQRT num

outputs the square root of the input, which must be nonnegative.


File: ucblogo.info,  Node: POWER,  Next: EXP,  Prev: SQRT,  Up: NUMERIC OPERATIONS

power
-----

     POWER num1 num2

outputs `num1' to the `num2' power.  If num1 is negative, then num2
must be an integer.


File: ucblogo.info,  Node: EXP,  Next: LOG10,  Prev: POWER,  Up: NUMERIC OPERATIONS

exp
---

     EXP num

outputs e (2.718281828+) to the input power.


File: ucblogo.info,  Node: LOG10,  Next: LN,  Prev: EXP,  Up: NUMERIC OPERATIONS

log10
-----

     LOG10 num

outputs the common logarithm of the input.


File: ucblogo.info,  Node: LN,  Next: SIN,  Prev: LOG10,  Up: NUMERIC OPERATIONS

ln
--

     LN num

outputs the natural logarithm of the input.


File: ucblogo.info,  Node: SIN,  Next: RADSIN,  Prev: LN,  Up: NUMERIC OPERATIONS

sin
---

     SIN degrees

outputs the sine of its input, which is taken in degrees.


File: ucblogo.info,  Node: RADSIN,  Next: COS,  Prev: SIN,  Up: NUMERIC OPERATIONS

radsin
------

     RADSIN radians

outputs the sine of its input, which is taken in radians.


File: ucblogo.info,  Node: COS,  Next: RADCOS,  Prev: RADSIN,  Up: NUMERIC OPERATIONS

cos
---

     COS degrees

outputs the cosine of its input, which is taken in degrees.


File: ucblogo.info,  Node: RADCOS,  Next: ARCTAN,  Prev: COS,  Up: NUMERIC OPERATIONS

radcos
------

     RADCOS radians

outputs the cosine of its input, which is taken in radians.


File: ucblogo.info,  Node: ARCTAN,  Next: RADARCTAN,  Prev: RADCOS,  Up: NUMERIC OPERATIONS

arctan
------

     ARCTAN num
     (ARCTAN x y)

outputs the arctangent, in degrees, of its input.  With two inputs,
outputs the arctangent of y/x, if x is nonzero, or 90 or -90 depending
on the sign of y, if x is zero.


File: ucblogo.info,  Node: RADARCTAN,  Next: ISEQ,  Prev: ARCTAN,  Up: NUMERIC OPERATIONS

radarctan
---------

     RADARCTAN num
     (RADARCTAN x y)

outputs the arctangent, in radians, of its input.  With two inputs,
outputs the arctangent of y/x, if x is nonzero, or pi/2 or -pi/2
depending on the sign of y, if x is zero.

The expression 2*(RADARCTAN 0 1) can be used to get the value of pi.


File: ucblogo.info,  Node: ISEQ,  Next: RSEQ,  Prev: RADARCTAN,  Up: NUMERIC OPERATIONS

iseq
----

     ISEQ from to					(library procedure)

outputs a list of the integers from FROM to TO, inclusive.

     ? show iseq 3 7
     [3 4 5 6 7]
     ? show iseq 7 3
     [7 6 5 4 3]


File: ucblogo.info,  Node: RSEQ,  Prev: ISEQ,  Up: NUMERIC OPERATIONS

rseq
----

     RSEQ from to count				(library procedure)

outputs a list of COUNT equally spaced rational numbers between FROM and
TO, inclusive.

     ? show rseq 3 5 9
     [3 3.25 3.5 3.75 4 4.25 4.5 4.75 5]
     ? show rseq 3 5 5
     [3 3.5 4 4.5 5]


File: ucblogo.info,  Node: NUMERIC PREDICATES,  Next: RANDOM NUMBERS,  Prev: NUMERIC OPERATIONS,  Up: ARITHMETIC

Numeric Predicates
==================

* Menu:

* LESSP::
* GREATERP::


File: ucblogo.info,  Node: LESSP,  Next: GREATERP,  Up: NUMERIC PREDICATES

lessp
-----

     LESSP num1 num2
     LESS? num1 num2
     num1 < num2

outputs TRUE if its first input is strictly less than its second.


File: ucblogo.info,  Node: GREATERP,  Prev: LESSP,  Up: NUMERIC PREDICATES

greaterp
--------

     GREATERP num1 num2
     GREATER? num1 num2
     num1 > num2

outputs TRUE if its first input is strictly greater than its second.


File: ucblogo.info,  Node: RANDOM NUMBERS,  Next: PRINT FORMATTING,  Prev: NUMERIC PREDICATES,  Up: ARITHMETIC

Random Numbers
==============

* Menu:

* RANDOM::
* RERANDOM::


File: ucblogo.info,  Node: RANDOM,  Next: RERANDOM,  Up: RANDOM NUMBERS

random
------

     RANDOM num

outputs a random nonnegative integer less than its input, which must be
an integer.


File: ucblogo.info,  Node: RERANDOM,  Prev: RANDOM,  Up: RANDOM NUMBERS

rerandom
--------

     RERANDOM
     (RERANDOM seed)

command.  Makes the results of RANDOM reproducible.  Ordinarily the
sequence of random numbers is different each time Logo is used.  If you
need the same sequence of pseudo-random numbers repeatedly, e.g. to
debug a program, say RERANDOM before the first invocation of RANDOM.  If
you need more than one repeatable sequence, you can give RERANDOM an
integer input; each possible input selects a unique sequence of numbers.


File: ucblogo.info,  Node: PRINT FORMATTING,  Next: BITWISE OPERATIONS,  Prev: RANDOM NUMBERS,  Up: ARITHMETIC

Print Formatting
================

* Menu:

* FORM::


File: ucblogo.info,  Node: FORM,  Up: PRINT FORMATTING

form
----

     FORM num width precision

outputs a word containing a printable representation of `num', possibly
preceded by spaces (and therefore not a number for purposes of
performing arithmetic operations), with at least `width' characters,
including exactly `precision' digits after the decimal point.  (If
`precision' is 0 then there will be no decimal point in the output.)

As a debugging feature, (FORM num -1 format) will print the floating
point `num' according to the C printf `format', to allow

     to hex :num
     op form :num -1 "|%08X %08X|
     end

to allow finding out the exact result of floating point operations.  The
precise format needed may be machine-dependent.


File: ucblogo.info,  Node: BITWISE OPERATIONS,  Prev: PRINT FORMATTING,  Up: ARITHMETIC

Bitwise Operations
==================

* Menu:

* BITAND::
* BITOR::
* BITXOR::
* BITNOT::
* ASHIFT::
* LSHIFT::


File: ucblogo.info,  Node: BITAND,  Next: BITOR,  Up: BITWISE OPERATIONS

bitand
------

     BITAND num1 num2
     (BITAND num1 num2 num3 ...)

outputs the bitwise AND of its inputs, which must be integers.

*Note AND::


File: ucblogo.info,  Node: BITOR,  Next: BITXOR,  Prev: BITAND,  Up: BITWISE OPERATIONS

bitor
-----

     BITOR num1 num2
     (BITOR num1 num2 num3 ...)

outputs the bitwise OR of its inputs, which must be integers.

*Note OR::


File: ucblogo.info,  Node: BITXOR,  Next: BITNOT,  Prev: BITOR,  Up: BITWISE OPERATIONS

bitxor
------

     BITXOR num1 num2
     (BITXOR num1 num2 num3 ...)

outputs the bitwise EXCLUSIVE OR of its inputs, which must be integers.

*Note OR::


File: ucblogo.info,  Node: BITNOT,  Next: ASHIFT,  Prev: BITXOR,  Up: BITWISE OPERATIONS

bitnot
------

     BITNOT num

outputs the bitwise NOT of its input, which must be an integer.

*Note NOT::


File: ucblogo.info,  Node: ASHIFT,  Next: LSHIFT,  Prev: BITNOT,  Up: BITWISE OPERATIONS

ashift
------

     ASHIFT num1 num2

outputs `num1' arithmetic-shifted to the left by `num2' bits.  If num2
is negative, the shift is to the right with sign extension.  The inputs
must be integers.


File: ucblogo.info,  Node: LSHIFT,  Prev: ASHIFT,  Up: BITWISE OPERATIONS

lshift
------

     LSHIFT num1 num2

outputs `num1' logical-shifted to the left by `num2' bits.  If num2 is
negative, the shift is to the right with zero fill.  The inputs must be
integers.


File: ucblogo.info,  Node: LOGICAL OPERATIONS,  Next: GRAPHICS,  Prev: ARITHMETIC,  Up: Top

Logical Operations
******************

* Menu:

* AND::
* OR::
* NOT::


File: ucblogo.info,  Node: AND,  Next: OR,  Up: LOGICAL OPERATIONS

and
---

     AND tf1 tf2
     (AND tf1 tf2 tf3 ...)

outputs TRUE if all inputs are TRUE, otherwise FALSE.  All inputs must
be TRUE or FALSE.  (Comparison is case-insensitive regardless of the
value of CASEIGNOREDP.  That is, `true' or `True' or `TRUE' are all the
same.)

*Note CASEIGNOREDP::


File: ucblogo.info,  Node: OR,  Next: NOT,  Prev: AND,  Up: LOGICAL OPERATIONS

or
--

     OR tf1 tf2
     (OR tf1 tf2 tf3 ...)

outputs TRUE if any input is TRUE, otherwise FALSE.  All inputs must be
TRUE or FALSE.  (Comparison is case-insensitive regardless of the value
of CASEIGNOREDP.  That is, `true' or `True' or `TRUE' are all the same.)

*Note CASEIGNOREDP::


File: ucblogo.info,  Node: NOT,  Prev: OR,  Up: LOGICAL OPERATIONS

not
---

     NOT tf

outputs TRUE if the input is FALSE, and vice versa.


File: ucblogo.info,  Node: GRAPHICS,  Next: WORKSPACE MANAGEMENT,  Prev: LOGICAL OPERATIONS,  Up: Top

Graphics
********

Berkeley Logo provides traditional Logo turtle graphics with one turtle.
Multiple turtles, dynamic turtles, and collision detection are not
supported.  This is the most hardware-dependent part of Logo; some
features may exist on some machines but not others.  Nevertheless, the
goal has been to make Logo programs as portable as possible, rather
than to take fullest advantage of the capabilities of each machine.  In
particular, Logo attempts to scale the screen so that turtle
coordinates [-100 -100] and [100 100] fit on the graphics window, and
so that the aspect ratio is 1:1, although some PC screens have
nonstandard aspect ratios.

The center of the graphics window (which may or may not be the entire
screen, depending on the machine used) is turtle location [0 0].
Positive X is to the right; positive Y is up.  Headings (angles) are
measured in degrees clockwise from the positive Y axis.  (This differs
from the common mathematical convention of measuring angles
counterclockwise from the positive X axis.)  The turtle is represented
as an isoceles triangle; the actual turtle position is at the midpoint
of the base (the short side).

Colors are, of course, hardware-dependent.  However, Logo provides
partial hardware independence by interpreting color numbers 0 through 7
uniformly on all computers:

     0  black        1  blue         2  green        3  cyan
     4  red          5  magenta      6  yellow       7 white

Where possible, Logo provides additional user-settable colors; how many
are available depends on the hardware and operating system environment.
If at least 16 colors are available, Logo tries to provide uniform
initial settings for the colors 8-15:

      8  brown        9  tan         10  forest      11  aqua
     12  salmon      13  purple      14  orange      15  grey

Logo begins with a black background and white pen.

* Menu:

* TURTLE MOTION::
* TURTLE MOTION QUERIES::
* TURTLE AND WINDOW CONTROL::
* TURTLE AND WINDOW QUERIES::
* PEN AND BACKGROUND CONTROL::
* PEN QUERIES::


File: ucblogo.info,  Node: TURTLE MOTION,  Next: TURTLE MOTION QUERIES,  Up: GRAPHICS

Turtle Motion
=============

* Menu:

* FORWARD::
* BACK::
* LEFT::
* RIGHT::
* SETPOS::
* SETXY::
* SETX::
* SETY::
* HOME::
* SETHEADING::
* ARC::


File: ucblogo.info,  Node: FORWARD,  Next: BACK,  Up: TURTLE MOTION

forward
-------

     FORWARD dist
     FD dist

moves the turtle forward, in the direction that it's facing, by the
specified distance (measured in turtle steps).


File: ucblogo.info,  Node: BACK,  Next: LEFT,  Prev: FORWARD,  Up: TURTLE MOTION

back
----

     BACK dist
     BK dist

moves the turtle backward, i.e., exactly opposite to the direction that
it's facing, by the specified distance.  (The heading of the turtle does
not change.)


File: ucblogo.info,  Node: LEFT,  Next: RIGHT,  Prev: BACK,  Up: TURTLE MOTION

left
----

     LEFT degrees
     LT degrees

turns the turtle counterclockwise by the specified angle, measured in
degrees (1/360 of a circle).


File: ucblogo.info,  Node: RIGHT,  Next: SETPOS,  Prev: LEFT,  Up: TURTLE MOTION

right
-----

     RIGHT degrees
     RT degrees

turns the turtle clockwise by the specified angle, measured in degrees
(1/360 of a circle).


File: ucblogo.info,  Node: SETPOS,  Next: SETXY,  Prev: RIGHT,  Up: TURTLE MOTION

setpos
------

     SETPOS pos

moves the turtle to an absolute screen position.  The argument is a list
of two numbers, the X and Y coordinates.


File: ucblogo.info,  Node: SETXY,  Next: SETX,  Prev: SETPOS,  Up: TURTLE MOTION

setxy
-----

     SETXY xcor ycor

moves the turtle to an absolute screen position.  The two arguments are
numbers, the X and Y coordinates.


File: ucblogo.info,  Node: SETX,  Next: SETY,  Prev: SETXY,  Up: TURTLE MOTION

setx
----

     SETX xcor

moves the turtle horizontally from its old position to a new absolute
horizontal coordinate.  The argument is the new X coordinate.


File: ucblogo.info,  Node: SETY,  Next: HOME,  Prev: SETX,  Up: TURTLE MOTION

sety
----

     SETY ycor

moves the turtle vertically from its old position to a new absolute
vertical coordinate.  The argument is the new Y coordinate.


File: ucblogo.info,  Node: HOME,  Next: SETHEADING,  Prev: SETY,  Up: TURTLE MOTION

home
----

     HOME

moves the turtle to the center of the screen.  Equivalent to
SETPOS [0 0].

*Note SETPOS::


File: ucblogo.info,  Node: SETHEADING,  Next: ARC,  Prev: HOME,  Up: TURTLE MOTION

setheading
----------

     SETHEADING degrees
     SETH degrees

turns the turtle to a new absolute heading.  The argument is a number,
the heading in degrees clockwise from the positive Y axis.


File: ucblogo.info,  Node: ARC,  Prev: SETHEADING,  Up: TURTLE MOTION

arc
---

     ARC angle radius

draws an arc of a circle, with the turtle at the center, with the
specified radius, starting at the turtle's heading and extending
clockwise through the specified angle.  The turtle does not move.


File: ucblogo.info,  Node: TURTLE MOTION QUERIES,  Next: TURTLE AND WINDOW CONTROL,  Prev: TURTLE MOTION,  Up: GRAPHICS

Turtle Motion Queries
=====================

* Menu:

* POS::
* XCOR::
* YCOR::
* HEADING::
* TOWARDS::
* SCRUNCH::


File: ucblogo.info,  Node: POS,  Next: XCOR,  Up: TURTLE MOTION QUERIES

pos
---

     POS

outputs the turtle's current position, as a list of two numbers, the X
and Y coordinates.


File: ucblogo.info,  Node: XCOR,  Next: YCOR,  Prev: POS,  Up: TURTLE MOTION QUERIES

xcor
----

     XCOR						(library procedure)

outputs a number, the turtle's X coordinate.


File: ucblogo.info,  Node: YCOR,  Next: HEADING,  Prev: XCOR,  Up: TURTLE MOTION QUERIES

ycor
----

     YCOR						(library procedure)

outputs a number, the turtle's Y coordinate.


File: ucblogo.info,  Node: HEADING,  Next: TOWARDS,  Prev: YCOR,  Up: TURTLE MOTION QUERIES

heading
-------

     HEADING

outputs a number, the turtle's heading in degrees.


File: ucblogo.info,  Node: TOWARDS,  Next: SCRUNCH,  Prev: HEADING,  Up: TURTLE MOTION QUERIES

towards
-------

     TOWARDS pos

outputs a number, the heading at which the turtle should be facing so
that it would point from its current position to the position given as
the argument.


File: ucblogo.info,  Node: SCRUNCH,  Prev: TOWARDS,  Up: TURTLE MOTION QUERIES

scrunch
-------

     SCRUNCH

outputs a list containing two numbers, the X and Y scrunch factors, as
used by SETSCRUNCH.  (But note that SETSCRUNCH takes two numbers as
inputs, not one list of numbers.)

*Note SETSCRUNCH::


File: ucblogo.info,  Node: TURTLE AND WINDOW CONTROL,  Next: TURTLE AND WINDOW QUERIES,  Prev: TURTLE MOTION QUERIES,  Up: GRAPHICS

Turtle and Window Control
=========================

* Menu:

* SHOWTURTLE::
* HIDETURTLE::
* CLEAN::
* CLEARSCREEN::
* WRAP::
* WINDOW::
* FENCE::
* FILL::
* LABEL::
* TEXTSCREEN::
* FULLSCREEN::
* SPLITSCREEN::
* SETSCRUNCH::
* REFRESH::
* NOREFRESH::


File: ucblogo.info,  Node: SHOWTURTLE,  Next: HIDETURTLE,  Up: TURTLE AND WINDOW CONTROL

showturtle
----------

     SHOWTURTLE
     ST

makes the turtle visible.


File: ucblogo.info,  Node: HIDETURTLE,  Next: CLEAN,  Prev: SHOWTURTLE,  Up: TURTLE AND WINDOW CONTROL

hideturtle
----------

     HIDETURTLE
     HT

makes the turtle invisible.  It's a good idea to do this while you're in
the middle of a complicated drawing, because hiding the turtle speeds up
the drawing substantially.


File: ucblogo.info,  Node: CLEAN,  Next: CLEARSCREEN,  Prev: HIDETURTLE,  Up: TURTLE AND WINDOW CONTROL

clean
-----

     CLEAN

erases all lines that the turtle has drawn on the graphics window.  The
turtle's state (position, heading, pen mode, etc.) is not changed.


File: ucblogo.info,  Node: CLEARSCREEN,  Next: WRAP,  Prev: CLEAN,  Up: TURTLE AND WINDOW CONTROL

clearscreen
-----------

     CLEARSCREEN
     CS

erases the graphics window and sends the turtle to its initial position
and heading.  Like HOME and CLEAN together.

*Note HOME::


File: ucblogo.info,  Node: WRAP,  Next: WINDOW,  Prev: CLEARSCREEN,  Up: TURTLE AND WINDOW CONTROL

wrap
----

     WRAP

tells the turtle to enter wrap mode:  From now on, if the turtle is
asked to move past the boundary of the graphics window, it will "wrap
around" and reappear at the opposite edge of the window.  The top edge
wraps to the bottom edge, while the left edge wraps to the right edge.
(So the window is topologically equivalent to a torus.)  This is the
turtle's initial mode.  Compare WINDOW and FENCE.

*Note FENCE::


File: ucblogo.info,  Node: WINDOW,  Next: FENCE,  Prev: WRAP,  Up: TURTLE AND WINDOW CONTROL

window
------

     WINDOW

tells the turtle to enter window mode:  From now on, if the turtle is
asked to move past the boundary of the graphics window, it will move
offscreen.  The visible graphics window is considered as just part of an
infinite graphics plane; the turtle can be anywhere on the plane.  (If
you lose the turtle, HOME will bring it back to the center of the
window.)  Compare WRAP and FENCE.

*Note HOME::


File: ucblogo.info,  Node: FENCE,  Next: FILL,  Prev: WINDOW,  Up: TURTLE AND WINDOW CONTROL

fence
-----

     FENCE

tells the turtle to enter fence mode:  From now on, if the turtle is
asked to move past the boundary of the graphics window, it will move as
far as it can and then stop at the edge with an "out of bounds" error
message.  Compare WRAP and WINDOW.

*Note WRAP::


File: ucblogo.info,  Node: FILL,  Next: LABEL,  Prev: FENCE,  Up: TURTLE AND WINDOW CONTROL

fill
----

     FILL

fills in a region of the graphics window containing the turtle and
bounded by lines that have been drawn earlier.  This is not portable; it
doesn't work for all machines, and may not work exactly the same way on
different machines.


File: ucblogo.info,  Node: LABEL,  Next: TEXTSCREEN,  Prev: FILL,  Up: TURTLE AND WINDOW CONTROL

label
-----

     LABEL text

takes a word or list as input, and prints the input on the graphics
window, starting at the turtle's position.


File: ucblogo.info,  Node: TEXTSCREEN,  Next: FULLSCREEN,  Prev: LABEL,  Up: TURTLE AND WINDOW CONTROL

textscreen
----------

     TEXTSCREEN
     TS

rearranges the size and position of windows to maximize the space
available in the text window (the window used for interaction with
Logo).  The details differ among machines.  Compare SPLITSCREEN and
FULLSCREEN.

*Note SPLITSCREEN::


File: ucblogo.info,  Node: FULLSCREEN,  Next: SPLITSCREEN,  Prev: TEXTSCREEN,  Up: TURTLE AND WINDOW CONTROL

fullscreen
----------

     FULLSCREEN
     FS

rearranges the size and position of windows to maximize the space
available in the graphics window.  The details differ among machines.
Compare SPLITSCREEN and TEXTSCREEN.

In the DOS version, switching from fullscreen to splitscreen loses the
part of the picture that's hidden by the text window.  Also, since there
must be a text window to allow printing (including the printing of the
Logo prompt), Logo automatically switches from fullscreen to splitscreen
whenever anything is printed.  [This design decision follows from the
scarcity of memory, so that the extra memory to remember an invisible
part of a drawing seems too expensive.]


File: ucblogo.info,  Node: SPLITSCREEN,  Next: SETSCRUNCH,  Prev: FULLSCREEN,  Up: TURTLE AND WINDOW CONTROL

splitscreen
-----------

     SPLITSCREEN
     SS

rearranges the size and position of windows to allow some room for text
interaction while also keeping most of the graphics window visible.  The
details differ among machines.  Compare TEXTSCREEN and FULLSCREEN.

*Note TEXTSCREEN::


File: ucblogo.info,  Node: SETSCRUNCH,  Next: REFRESH,  Prev: SPLITSCREEN,  Up: TURTLE AND WINDOW CONTROL

setscrunch
----------

     SETSCRUNCH xscale yscale

adjusts the aspect ratio and scaling of the graphics display.  After
this command is used, all further turtle motion will be adjusted by
multiplying the horizontal and vertical extent of the motion by the two
numbers given as inputs.  For example, after the instruction
`SETSCRUNCH 2 1' motion at a heading of 45 degrees will move twice as
far horizontally as vertically.  If your squares don't come out square,
try this.  (Alternatively, you can deliberately misadjust the aspect
ratio to draw an ellipse.)

For Unix machines and Macintoshes, both scale factors are initially 1.
For DOS machines, the scale factors are initially set according to what
the hardware claims the aspect ratio is, but the hardware sometimes
lies.  The values set by SETSCRUNCH are remembered in a file (called
SCRUNCH.DAT) and are automatically put into effect when a Logo session
begins.


File: ucblogo.info,  Node: REFRESH,  Next: NOREFRESH,  Prev: SETSCRUNCH,  Up: TURTLE AND WINDOW CONTROL

refresh
-------

     REFRESH

tells Logo to remember the turtle's motions so that they can be
reconstructed in case the graphics window is overlayed.  The
effectiveness of this command may depend on the machine used.


File: ucblogo.info,  Node: NOREFRESH,  Prev: REFRESH,  Up: TURTLE AND WINDOW CONTROL

norefresh
---------

     NOREFRESH

tells Logo not to remember the turtle's motions.  This will make drawing
faster, but prevents recovery if the window is overlayed.


File: ucblogo.info,  Node: TURTLE AND WINDOW QUERIES,  Next: PEN AND BACKGROUND CONTROL,  Prev: TURTLE AND WINDOW CONTROL,  Up: GRAPHICS

Turtle and Window Queries
=========================

* Menu:

* SHOWNP::


File: ucblogo.info,  Node: SHOWNP,  Up: TURTLE AND WINDOW QUERIES

shownp
------

     SHOWNP
     SHOWN?

outputs TRUE if the turtle is shown (visible), FALSE if the turtle is
hidden.  See SHOWTURTLE and HIDETURTLE.

*Note SHOWTURTLE:: ; *Note HIDETURTLE::


File: ucblogo.info,  Node: PEN AND BACKGROUND CONTROL,  Next: PEN QUERIES,  Prev: TURTLE AND WINDOW QUERIES,  Up: GRAPHICS

Pen and Background Control
==========================

The turtle carries a pen that can draw pictures.  At any time the pen
can be UP (in which case moving the turtle does not change what's on the
graphics screen) or DOWN (in which case the turtle leaves a trace).  If
the pen is down, it can operate in one of three modes: PAINT (so that it
draws lines when the turtle moves), ERASE (so that it erases any lines
that might have been drawn on or through that path earlier), or REVERSE
(so that it inverts the status of each point along the turtle's path).

* Menu:

* PENDOWN::
* PENUP::
* PENPAINT::
* PENERASE::
* PENREVERSE::
* SETPENCOLOR::
* SETPALETTE::
* SETPENSIZE::
* SETPENPATTERN::
* SETPEN::
* SETBACKGROUND::


File: ucblogo.info,  Node: PENDOWN,  Next: PENUP,  Up: PEN AND BACKGROUND CONTROL

pendown
-------

     PENDOWN
     PD

sets the pen's position to DOWN, without changing its mode.


File: ucblogo.info,  Node: PENUP,  Next: PENPAINT,  Prev: PENDOWN,  Up: PEN AND BACKGROUND CONTROL

penup
-----

     PENUP
     PU

sets the pen's position to UP, without changing its mode.


File: ucblogo.info,  Node: PENPAINT,  Next: PENERASE,  Prev: PENUP,  Up: PEN AND BACKGROUND CONTROL

penpaint
--------

     PENPAINT
     PPT

sets the pen's position to DOWN and mode to PAINT.


File: ucblogo.info,  Node: PENERASE,  Next: PENREVERSE,  Prev: PENPAINT,  Up: PEN AND BACKGROUND CONTROL

penerase
--------

     PENERASE
     PE

sets the pen's position to DOWN and mode to ERASE.

*Note ERASE::


File: ucblogo.info,  Node: PENREVERSE,  Next: SETPENCOLOR,  Prev: PENERASE,  Up: PEN AND BACKGROUND CONTROL

penreverse
----------

     PENREVERSE
     PX

sets the pen's position to DOWN and mode to REVERSE.  (This may interact
in hardware-dependent ways with use of color.)

*Note REVERSE::


File: ucblogo.info,  Node: SETPENCOLOR,  Next: SETPALETTE,  Prev: PENREVERSE,  Up: PEN AND BACKGROUND CONTROL

setpencolor
-----------

     SETPENCOLOR colornumber
     SETPC colornumber

sets the pen color to the given number, which must be a nonnegative
integer.  Color 0 is always black; color 7 is always white.  Other
colors may or may not be consistent between machines.


File: ucblogo.info,  Node: SETPALETTE,  Next: SETPENSIZE,  Prev: SETPENCOLOR,  Up: PEN AND BACKGROUND CONTROL

setpalette
----------

     SETPALETTE colornumber rgblist

sets the actual color corresponding to a given number, if allowed by the
hardware and operating system.  Colornumber must be an integer greater
than or equal to 8.  (Logo tries to keep the first 8 colors constant.)
The second argument is a list of three nonnegative integers less than
64K (65536) specifying the amount of red, green, and blue in the desired
color.  The actual color resolution on any screen is probably less than
64K, but Logo scales as needed.


File: ucblogo.info,  Node: SETPENSIZE,  Next: SETPENPATTERN,  Prev: SETPALETTE,  Up: PEN AND BACKGROUND CONTROL

setpensize
----------

     SETPENSIZE size
     SETPENPATTERN pattern

set hardware-dependent pen characteristics.  These commands are not
guaranteed compatible between implementations on different machines.


File: ucblogo.info,  Node: SETPENPATTERN,  Next: SETPEN,  Prev: SETPENSIZE,  Up: PEN AND BACKGROUND CONTROL

setpenpattern
-------------

     SETPENSIZE size
     SETPENPATTERN pattern

set hardware-dependent pen characteristics.  These commands are not
guaranteed compatible between implementations on different machines.


File: ucblogo.info,  Node: SETPEN,  Next: SETBACKGROUND,  Prev: SETPENPATTERN,  Up: PEN AND BACKGROUND CONTROL

setpen
------

     SETPEN list					(library procedure)

sets the pen's position, mode, and hardware-dependent characteristics
according to the information in the input list, which should be taken
from an earlier invocation of PEN.

*Note PEN::


File: ucblogo.info,  Node: SETBACKGROUND,  Prev: SETPEN,  Up: PEN AND BACKGROUND CONTROL

setbackground
-------------

     SETBACKGROUND color
     SETBG color

set the screen background color.


File: ucblogo.info,  Node: PEN QUERIES,  Prev: PEN AND BACKGROUND CONTROL,  Up: GRAPHICS

Pen Queries
===========

* Menu:

* PENDOWNP::
* PENMODE::
* PENCOLOR::
* PALETTE::
* PENSIZE::
* PEN::
* BACKGROUND::


File: ucblogo.info,  Node: PENDOWNP,  Next: PENMODE,  Up: PEN QUERIES

pendownp
--------

     PENDOWNP
     PENDOWN?

outputs TRUE if the pen is down, FALSE if it's up.


File: ucblogo.info,  Node: PENMODE,  Next: PENCOLOR,  Prev: PENDOWNP,  Up: PEN QUERIES

penmode
-------

     PENMODE

outputs one of the words PAINT, ERASE, or REVERSE according to the
current pen mode.

*Note ERASE:: ; *Note REVERSE::


File: ucblogo.info,  Node: PENCOLOR,  Next: PALETTE,  Prev: PENMODE,  Up: PEN QUERIES

pencolor
--------

     PENCOLOR
     PC

outputs a color number, a nonnegative integer that is associated with a
particular color by the hardware and operating system.


File: ucblogo.info,  Node: PALETTE,  Next: PENSIZE,  Prev: PENCOLOR,  Up: PEN QUERIES

palette
-------

     PALETTE colornumber

outputs a list of three integers, each in the range 0-65535,
representing the amount of red, green, and blue in the color associated
with the given number.


File: ucblogo.info,  Node: PENSIZE,  Next: PEN,  Prev: PALETTE,  Up: PEN QUERIES

pensize
-------

     PENSIZE
     PENPATTERN

output hardware-specific pen information.


File: ucblogo.info,  Node: PEN,  Next: BACKGROUND,  Prev: PENSIZE,  Up: PEN QUERIES

pen
---

     PEN						(library procedure)

outputs a list containing the pen's position, mode, and
hardware-specific characteristics, for use by SETPEN.

*Note SETPEN::


File: ucblogo.info,  Node: BACKGROUND,  Prev: PEN,  Up: PEN QUERIES

background
----------

     BACKGROUND
     BG

outputs the graphics background color.


File: ucblogo.info,  Node: WORKSPACE MANAGEMENT,  Next: CONTROL STRUCTURES,  Prev: GRAPHICS,  Up: Top

Workspace Management
********************

* Menu:

* PROCEDURE DEFINITION::
* VARIABLE DEFINITION::
* PROPERTY LISTS::
* WORKSPACE PREDICATES::
* WORKSPACE QUERIES::
* WORKSPACE INSPECTION::
* WORKSPACE CONTROL::


File: ucblogo.info,  Node: PROCEDURE DEFINITION,  Next: VARIABLE DEFINITION,  Up: WORKSPACE MANAGEMENT

Procedure Definition
====================

* Menu:

* TO::
* DEFINE::
* TEXT::
* FULLTEXT::
* COPYDEF::


File: ucblogo.info,  Node: TO,  Next: DEFINE,  Up: PROCEDURE DEFINITION

to
--

     TO procname :input1 :input2 ...			(special form)

command.  Prepares Logo to accept a procedure definition.  The procedure
will be named `procname' and there must not already be a procedure by
that name.  The inputs will be called `input1' etc.  Any number of
inputs are allowed, including none.  Names of procedures and inputs are
case-insensitive.

Unlike every other Logo procedure, TO takes as its inputs the actual
words typed in the instruction line, as if they were all quoted, rather
than the results of evaluating expressions to provide the inputs.
(That's what "special form" means.)

This version of Logo allows variable numbers of inputs to a procedure.
Every procedure has a MINIMUM, DEFAULT, and MAXIMUM number of inputs.
(The latter can be infinite.)

The MINIMUM number of inputs is the number of required inputs, which
must come first.  A required input is indicated by the

     :inputname

notation.

After all the required inputs can be zero or more optional inputs,
represented by the following notation:

     [:inputname default.value.expression]

When the procedure is invoked, if actual inputs are not supplied for
these optional inputs, the default value expressions are evaluated to
set values for the corresponding input names.  The inputs are processed
from left to right, so a default value expression can be based on
earlier inputs.  Example:

     to proc :inlist [:startvalue first :inlist]

If the procedure is invoked by saying

     proc [a b c]

then the variable `inlist' will have the value [A B C] and the variable
`startvalue' will have the value A.  If the procedure is invoked by
saying

     (proc [a b c] "x)

then `inlist' will have the value [A B C] and `startvalue' will have
the value X.

After all the required and optional input can come a single `rest'
input, represented by the following notation:

     [:inputname]

This is a rest input rather than an optional input because there is no
default value expression.  There can be at most one rest input.  When
the procedure is invoked, the value of this input will be a list
containing all of the actual inputs provided that were not used for
required or optional inputs.  Example:

     to proc :in1 [:in2 "foo] [:in3]

If this procedure is invoked by saying

     proc "x

then `in1' has the value X, `in2' has the value FOO, and `in3' has the
value [] (the empty list).  If it's invoked by saying

     (proc "a "b "c "d)

then `in1' has the value A, `in2' has the value B, and `in3' has the
value [C D].

The MAXIMUM number of inputs for a procedure is infinite if a rest input
is given; otherwise, it is the number of required inputs plus the number
of optional inputs.

The DEFAULT number of inputs for a procedure, which is the number of
inputs that it will accept if its invocation is not enclosed in
parentheses, is ordinarily equal to the minimum number.  If you want a
different default number you can indicate that by putting the desired
default number as the last thing on the TO line.  example:

     to proc :in1 [:in2 "foo] [:in3] 3

This procedure has a minimum of one input, a default of three inputs,
and an infinite maximum.

Logo responds to the TO command by entering procedure definition mode.
The prompt character changes from `?' to `>' and whatever instructions
you type become part of the definition until you type a line containing
only the word END.


File: ucblogo.info,  Node: DEFINE,  Next: TEXT,  Prev: TO,  Up: PROCEDURE DEFINITION

define
------

     DEFINE procname text

command.  Defines a procedure with name `procname' and text `text'.  If
there is already a procedure with the same name, the new definition
replaces the old one.  The text input must be a list whose members are
lists.  The first member is a list of inputs; it looks like a TO line
but without the word TO, without the procedure name, and without the
colons before input names.  In other words, the members of this first
sublist are words for the names of required inputs and lists for the
names of optional or rest inputs.  The remaining sublists of the text
input make up the body of the procedure, with one sublist for each
instruction line of the body.  (There is no END line in the text input.)
It is an error to redefine a primitive procedure unless the variable
REDEFP has the value TRUE.

*Note REDEFP::


File: ucblogo.info,  Node: TEXT,  Next: FULLTEXT,  Prev: DEFINE,  Up: PROCEDURE DEFINITION

text
----

     TEXT procname

outputs the text of the procedure named `procname' in the form expected
by DEFINE: a list of lists, the first of which describes the inputs to
the procedure and the rest of which are the lines of its body.  The text
does not reflect formatting information used when the procedure was
defined, such as continuation lines and extra spaces.


File: ucblogo.info,  Node: FULLTEXT,  Next: COPYDEF,  Prev: TEXT,  Up: PROCEDURE DEFINITION

fulltext
--------

     FULLTEXT procname

outputs a representation of the procedure `procname' in which formatting
information is preserved.  If the procedure was defined with TO, EDIT,
or LOAD, then the output is a list of words.  Each word represents one
entire line of the definition in the form output by READWORD, including
extra spaces and continuation lines.  The last member of the output
represents the END line.  If the procedure was defined with DEFINE, then
the output is a list of lists.  If these lists are printed, one per
line, the result will look like a definition using TO.  Note: the output
from FULLTEXT is not suitable for use as input to DEFINE!

*Note TO:: ; *Note EDIT:: ; *Note LOAD:: ; *Note DEFINE::


File: ucblogo.info,  Node: COPYDEF,  Prev: FULLTEXT,  Up: PROCEDURE DEFINITION

copydef
-------

     COPYDEF newname oldname

command.  Makes `newname' a procedure identical to `oldname'.  The
latter may be a primitive.  If `newname' was already defined, its
previous definition is lost.  If `newname' was already a primitive, the
redefinition is not permitted unless the variable REDEFP has the value
TRUE.  Definitions created by COPYDEF are not saved by SAVE; primitives
are never saved, and user-defined procedures created by COPYDEF are
buried.  (You are likely to be confused if you PO or POT a procedure
defined with COPYDEF because its title line will contain the old name.
This is why it's buried.)

Note: dialects of Logo differ as to the order of inputs to COPYDEF.
This dialect uses "MAKE order," not "NAME order."

*Note REDEFP:: ; *Note SAVE:: ; *Note PO:: ; *Note POT::


File: ucblogo.info,  Node: VARIABLE DEFINITION,  Next: PROPERTY LISTS,  Prev: PROCEDURE DEFINITION,  Up: WORKSPACE MANAGEMENT

Variable Definition
===================

* Menu:

* MAKE::
* NAME::
* LOCAL::
* THING::


File: ucblogo.info,  Node: MAKE,  Next: NAME,  Up: VARIABLE DEFINITION

make
----

     MAKE varname value

command.  Assigns the value `value' to the variable named `varname',
which must be a word.  Variable names are case-insensitive.  If a
variable with the same name already exists, the value of that variable
is changed.  If not, a new global variable is created.


File: ucblogo.info,  Node: NAME,  Next: LOCAL,  Prev: MAKE,  Up: VARIABLE DEFINITION

name
----

     NAME value varname				(library procedure)

command.  Same as MAKE but with the inputs in reverse order.


File: ucblogo.info,  Node: LOCAL,  Next: THING,  Prev: NAME,  Up: VARIABLE DEFINITION

local
-----

     LOCAL varname
     LOCAL varnamelist
     (LOCAL varname1 varname2 ...)

command.  Accepts as inputs one or more words, or a list of words.  A
variable is created for each of these words, with that word as its name.
The variables are local to the currently running procedure.  Logo
variables follow dynamic scope rules; a variable that is local to a
procedure is available to any subprocedure invoked by that procedure.
The variables created by LOCAL have no initial value; they must be
assigned a value (e.g., with MAKE) before the procedure attempts to read
their value.

*Note MAKE::


File: ucblogo.info,  Node: THING,  Prev: LOCAL,  Up: VARIABLE DEFINITION

thing
-----

     THING varname
     :quoted.varname

outputs the value of the variable whose name is the input.  If there is
more than one such variable, the innermost local variable of that name
is chosen.  The colon notation is an abbreviation not for THING but for
the combination

     thing "

so that :FOO means THING "FOO.


File: ucblogo.info,  Node: PROPERTY LISTS,  Next: WORKSPACE PREDICATES,  Prev: VARIABLE DEFINITION,  Up: WORKSPACE MANAGEMENT

Property Lists
==============

Note: Names of property lists are always case-insensitive.  Names of
individual properties are case-sensitive or case-insensitive depending
on the value of CASEIGNOREDP, which is TRUE by default.

*Note CASEIGNOREDP::

* Menu:

* PPROP::
* GPROP::
* REMPROP::
* PLIST::


File: ucblogo.info,  Node: PPROP,  Next: GPROP,  Up: PROPERTY LISTS

pprop
-----

     PPROP plistname propname value

command.  Adds a property to the `plistname' property list with name
`propname' and value `value'.


File: ucblogo.info,  Node: GPROP,  Next: REMPROP,  Prev: PPROP,  Up: PROPERTY LISTS

gprop
-----

     GPROP plistname propname

outputs the value of the `propname' property in the `plistname' property
list, or the empty list if there is no such property.


File: ucblogo.info,  Node: REMPROP,  Next: PLIST,  Prev: GPROP,  Up: PROPERTY LISTS

remprop
-------

     REMPROP plistname propname

command.  Removes the property named `propname' from the property list
named `plistname'.


File: ucblogo.info,  Node: PLIST,  Prev: REMPROP,  Up: PROPERTY LISTS

plist
-----

     PLIST plistname

outputs a list whose odd-numbered members are the names, and whose
even-numbered members are the values, of the properties in the property
list named `plistname'.  The output is a copy of the actual property
list; changing properties later will not magically change a list output
earlier by PLIST.


File: ucblogo.info,  Node: WORKSPACE PREDICATES,  Next: WORKSPACE QUERIES,  Prev: PROPERTY LISTS,  Up: WORKSPACE MANAGEMENT

Workspace Predicates
====================

* Menu:

* PROCEDUREP::
* PRIMITIVEP::
* DEFINEDP::
* NAMEP::


File: ucblogo.info,  Node: PROCEDUREP,  Next: PRIMITIVEP,  Up: WORKSPACE PREDICATES

procedurep
----------

     PROCEDUREP name
     PROCEDURE? name

outputs TRUE if the input is the name of a procedure.


File: ucblogo.info,  Node: PRIMITIVEP,  Next: DEFINEDP,  Prev: PROCEDUREP,  Up: WORKSPACE PREDICATES

primitivep
----------

     PRIMITIVEP name
     PRIMITIVE? name

outputs TRUE if the input is the name of a primitive procedure (one
built into Logo).  Note that some of the procedures described in this
document are library procedures, not primitives.


File: ucblogo.info,  Node: DEFINEDP,  Next: NAMEP,  Prev: PRIMITIVEP,  Up: WORKSPACE PREDICATES

definedp
--------

     DEFINEDP name
     DEFINED? name

outputs TRUE if the input is the name of a user-defined procedure,
including a library procedure.  (However, Logo does not know about a
library procedure until that procedure has been invoked.)


File: ucblogo.info,  Node: NAMEP,  Prev: DEFINEDP,  Up: WORKSPACE PREDICATES

namep
-----

     NAMEP name
     NAME? name

outputs TRUE if the input is the name of a variable.


File: ucblogo.info,  Node: WORKSPACE QUERIES,  Next: WORKSPACE INSPECTION,  Prev: WORKSPACE PREDICATES,  Up: WORKSPACE MANAGEMENT

Workspace Queries
=================

* Menu:

* CONTENTS::
* BURIED::
* PROCEDURES::
* NAMES::
* PLISTS::
* NAMELIST::
* PLLIST::
* NODES::
* GC::


File: ucblogo.info,  Node: CONTENTS,  Next: BURIED,  Up: WORKSPACE QUERIES

contents
--------

     CONTENTS

outputs a "contents list," i.e., a list of three lists containing names
of defined procedures, variables, and property lists respectively.  This
list includes all unburied named items in the workspace.


File: ucblogo.info,  Node: BURIED,  Next: PROCEDURES,  Prev: CONTENTS,  Up: WORKSPACE QUERIES

buried
------

     BURIED

outputs a contents list including all buried named items in the
workspace.


File: ucblogo.info,  Node: PROCEDURES,  Next: NAMES,  Prev: BURIED,  Up: WORKSPACE QUERIES

procedures
----------

     PROCEDURES

outputs a list of the names of all unburied user-defined procedures in
the workspace.  Note that this is a list of names, not a contents list.
(However, procedures that require a contents list as input will accept
this list.)


File: ucblogo.info,  Node: NAMES,  Next: PLISTS,  Prev: PROCEDURES,  Up: WORKSPACE QUERIES

names
-----

     NAMES

outputs a contents list consisting of an empty list (indicating no
procedure names) followed by a list of all unburied variable names in
the workspace.


File: ucblogo.info,  Node: PLISTS,  Next: NAMELIST,  Prev: NAMES,  Up: WORKSPACE QUERIES

plists
------

     PLISTS

outputs a contents list consisting of two empty lists (indicating no
procedures or variables) followed by a list of all unburied property
lists in the workspace.


File: ucblogo.info,  Node: NAMELIST,  Next: PLLIST,  Prev: PLISTS,  Up: WORKSPACE QUERIES

namelist
--------

     NAMELIST varname				(library procedure)
     NAMELIST varnamelist

outputs a contents list consisting of an empty list followed by a list
of the name or names given as input.  This is useful in conjunction with
workspace control procedures that require a contents list as input.


File: ucblogo.info,  Node: PLLIST,  Next: NODES,  Prev: NAMELIST,  Up: WORKSPACE QUERIES

pllist
------

     PLLIST plname					(library procedure)
     PLLIST plnamelist

outputs a contents list consisting of two empty lists followed by a list
of the name or names given as input.  This is useful in conjunction with
workspace control procedures that require a contents list as input.

Note:  All procedures whose input is indicated as `contentslist' will
accept a single word (taken as a procedure name), a list of words (taken
as names of procedures), or a list of three lists as described under the
CONTENTS command above.

*Note CONTENTS::


File: ucblogo.info,  Node: NODES,  Next: GC,  Prev: PLLIST,  Up: WORKSPACE QUERIES

nodes
-----

     NODES

outputs a list of two numbers.  The first represents the number of nodes
of memory currently in use.  The second shows the maximum number of
nodes that have been in use at any time since the last invocation of
NODES.  (A node is a small block of computer memory as used by Logo.
Each number uses one node.  Each non-numeric word uses one node, plus
some non-node memory for the characters in the word.  Each array takes
one node, plus some non-node memory, as well as the memory required by
its elements.  Each list requires one node per element, as well as the
memory within the elements.)  If you want to track the memory use of an
algorithm, it is best if you invoke GC at the beginning of each
iteration, since otherwise the maximum will include storage that is
unused but not yet collected.


File: ucblogo.info,  Node: GC,  Prev: NODES,  Up: WORKSPACE QUERIES

gc
--

     GC
     (GC anything)

command.  Runs the garbage collector, reclaiming unused nodes.  Logo
does this when necessary anyway, but you may want to use this command to
control exactly when Logo does it.  In particular, the numbers output by
the NODES operation will not be very meaningful unless garbage has been
collected.  Another reason to use GC is that a garbage collection takes
a noticeable fraction of a second, and you may want to schedule
collections for times before or after some time-critical animation.  If
invoked with an argument (of any value), GC runs a full garbage
collection, including GCTWA (Garbage Collect Truly Worthless Atoms,
which means that it removes from Logo's memory words that used to be
procedure or variable names but aren't any more); without an argument,
GC does a generational garbage collection, which means that only
recently created nodes are examined.  (The latter is usually good
enough.)


File: ucblogo.info,  Node: WORKSPACE INSPECTION,  Next: WORKSPACE CONTROL,  Prev: WORKSPACE QUERIES,  Up: WORKSPACE MANAGEMENT

Workspace Inspection
====================

* Menu:

* PO::
* POALL::
* POPS::
* PONS::
* POPLS::
* PON::
* POPL::
* POT::
* POTS::


File: ucblogo.info,  Node: PO,  Next: POALL,  Up: WORKSPACE INSPECTION

po
--

     PO contentslist

command.  Prints to the write stream the definitions of all procedures,
variables, and property lists named in the input contents list.


File: ucblogo.info,  Node: POALL,  Next: POPS,  Prev: PO,  Up: WORKSPACE INSPECTION

poall
-----

     POALL						(library procedure)

command.  Prints all unburied definitions in the workspace.  Abbreviates
PO CONTENTS.

*Note CONTENTS::


File: ucblogo.info,  Node: POPS,  Next: PONS,  Prev: POALL,  Up: WORKSPACE INSPECTION

pops
----

     POPS						(library procedure)

command.  Prints the definitions of all unburied procedures in the
workspace.  Abbreviates PO PROCEDURES.

*Note PO:: ; *Note PROCEDURES::


File: ucblogo.info,  Node: PONS,  Next: POPLS,  Prev: POPS,  Up: WORKSPACE INSPECTION

pons
----

     PONS						(library procedure)

command.  Prints the definitions of all unburied variables in the
workspace.  Abbreviates PO NAMES.

*Note PO:: ; *Note NAMES::


File: ucblogo.info,  Node: POPLS,  Next: PON,  Prev: PONS,  Up: WORKSPACE INSPECTION

popls
-----

     POPLS						(library procedure)

command.  Prints the contents of all unburied property lists in the
workspace.  Abbreviates PO PLISTS.

*Note PO:: ; *Note PLISTS::

